# 
# KDOM IDL parser
#
# Copyright (C) 2005 Nikolas Zimmermann <wildfox@kde.org>
# Copyright (C) 2006 Anders Carlsson <andersca@mac.com> 
# Copyright (C) 2006 Apple Computer, Inc.
#
# This file is part of the KDE project
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
# 
# You should have received a copy of the GNU Library General Public License
# aint with this library; see the file COPYING.LIB.  If not, write to
# the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#

package CodeGeneratorJS;

use File::stat;

my $module = "";
my $outputDir = "";
my %implIncludes = ();

# Default .h template
my $headerTemplate = << "EOF";
/*
    This file is part of the KDE project.
    This file has been generated by kdomidl.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/
EOF

# Default constructor
sub new
{
  my $object = shift;
  my $reference = { };

  $codeGenerator = shift;
  $outputDir = shift;

  bless($reference, $object);
  return $reference;
}

sub finish
{
  my $object = shift;

  # Commit changes!
  $object->WriteData();
}

# Params: 'domClass' struct
sub GenerateInterface
{
  my $object = shift;
  my $dataNode = shift;

  # FIXME: Check dates to see if we need to re-generate anything
  
  # Start actual generation..
  $object->GenerateHeader($dataNode);
  $object->GenerateImplementation($dataNode);

  my $name = $dataNode->name;
  
  # Open files for writing...
  my $headerFileName = "$outputDir/JS$name.h";
  my $implFileName = "$outputDir/JS$name.cpp";

  open($IMPL, ">$implFileName") || die "Couldn't open file $implFileName";
  open($HEADER, ">$headerFileName") || die "Couldn't open file $headerFileName";
}

# Params: 'idlDocument' struct
sub GenerateModule
{
  my $object = shift;
  my $dataNode = shift;  
  
  $module = $dataNode->module;

}

sub GetParentClassName
{
  my $dataNode = shift;
  return $dataNode->extendedAttributes->{"LegacyParent"} if $dataNode->extendedAttributes->{"LegacyParent"};
  return "KJS::DOMObject" if @{$dataNode->parents} eq 0;
  return "JS" . $dataNode->parents(0);
}

sub GetLegacyHeaderIncludes
{
  my $legacyParent = shift;
  if ($legacyParent eq "JSCanvasRenderingContext2DBase") {
    return "#include \"JSCanvasRenderingContext2DBase.h\"\n\n";
  } elsif ($legacyParent eq "KJS::Window") {
      return "#include \"kjs_window.h\"\n\n";
  } elsif ($module eq "events") {
    return "#include \"kjs_events.h\"\n\n";
  } elsif ($module eq "core") {
    return "#include \"kjs_dom.h\"\n\n";
  } elsif ($module eq "css") {
    return "#include \"kjs_css.h\"\n\n";
  } elsif ($module eq "html") {
    return "#include \"kjs_html.h\"\n\n";
  } elsif ($module eq "traversal") {
    return "#include \"kjs_traversal.h\"\n\n";
  } else {
    die ("Don't know what headers to include for module $module");
  }
}

sub AddIncludesForType
{
  my $type = shift;
  
  # When we're finished with the one-file-per-class 
  # reorganization, we don't need these special cases.
  
  if ($type eq "Attr" or
      $type eq "CDATASection" or
      $type eq "CanvasPattern" or
      $type eq "CharacterData" or
      $type eq "Comment" or
      $type eq "DOMException" or
      $type eq "DOMImplementation" or
      $type eq "DOMWindow" or
      $type eq "Document" or
      $type eq "DocumentFragment" or
      $type eq "DocumentType" or 
      $type eq "Element" or
      $type eq "HTMLCanvasElement" or
      $type eq "Node" or
      $type eq "NodeList" or 
      $type eq "Range" or 
      $type eq "Text") {
    $implIncludes{"${type}.h"} = 1;
  } elsif ($type eq "CSSStyleSheet" or $type eq "StyleSheet") {
    $implIncludes{"css_stylesheetimpl.h"} = 1;
  } elsif ($type eq "CSSRuleList" or
           $type eq "CSSRule") {
    $implIncludes{"css_ruleimpl.h"} = 1;
  } elsif ($type eq "CSSPrimitiveValue" or 
           $type eq "CSSValue" or
           $type eq "Counter" or 
           $type eq "Rect" or 
           $type eq "RGBColor") {
    $implIncludes{"css_valueimpl.h"} = 1;
  } elsif ($type eq "CSSStyleDeclaration") {
    $implIncludes{"css_valueimpl.h"} = 1;
  } elsif ($type eq "HTMLDocument") {
    $implIncludes{"HTMLDocument.h"} = 1;
  } elsif ($type eq "MutationEvent" or
           $type eq "KeyboardEvent" or
           $type eq "MouseEvent" or
           $type eq "Event" or
           $type eq "UIEvent" or
           $type eq "WheelEvent") {
    $implIncludes{"dom2_eventsimpl.h"} = 1;
  } elsif ($type eq "NodeIterator" or
           $type eq "NodeFilter" or
	   $type eq "TreeWalker") {
    $implIncludes{"dom2_traversalimpl.h"} = 1;
  } elsif ($type eq "ProcessingInstruction" or
           $type eq "Entity" or
	   $type eq "EntityReference" or
           $type eq "Notation") {
    $implIncludes{"dom_xmlimpl.h"} = 1;
  } elsif ($type eq "CanvasRenderingContext2D") {
    $implIncludes{"CanvasGradient.h"} = 1;
    $implIncludes{"CanvasPattern.h"} = 1;
    $implIncludes{"CanvasRenderingContext2D.h"} = 1;
    $implIncludes{"CanvasStyle.h"} = 1;
  } elsif ($type eq "CanvasGradient") {
    $implIncludes{"CanvasGradient.h"} = 1;
    $implIncludes{"PlatformString.h"} = 1;
  } elsif ($codeGenerator->IsPrimitiveType($type) or
           $type eq "DOMString" or $type eq "DOMObject") {
    # Do nothing
  } else {
    die "Don't know what to include for interface $type";
  }
}

sub GenerateHeader
{
  my $object = shift;
  my $dataNode = shift;

  my $interfaceName = $dataNode->name;
  my $className = "JS$interfaceName";
  my $implClassName = $interfaceName;
  
  # FIXME: If we're sure that an interface can't have more than
  # one parent we can do the check in the parser instead
  if (@{$dataNode->parents} > 1) {
    die "A class can't have more than one parent";
  }
  
  my $hasLegacyParent = $dataNode->extendedAttributes->{"LegacyParent"};
  my $hasRealParent = @{$dataNode->parents} > 0;
  my $hasParent = $hasLegacyParent || $hasRealParent;
  my $parentClassName = GetParentClassName($dataNode);
  
  # - Add default header template
  @headerContent = split("\r", $headerTemplate);

  # - Add header protection
  push(@headerContent, "\n#ifndef $className" . "_H");
  push(@headerContent, "\n#define $className" . "_H\n\n");
  
  if (exists $dataNode->extendedAttributes->{"LegacyParent"}) {
    push(@headerContent, GetLegacyHeaderIncludes($dataNode->extendedAttributes->{"LegacyParent"}));
  } else {
    if ($hasParent) {
      push(@headerContent, "#include \"$parentClassName.h\"\n");
    } else {
      push(@headerContent, "#include \"kjs_binding.h\"\n");
    }
  }
  
  my $numAttributes = @{$dataNode->attributes};
  my $numFunctions = @{$dataNode->functions};
  my $numConstants = @{$dataNode->constants};
  
  push(@headerContent, "\nnamespace WebCore {\n\n");
  
  # Implementation class forward declaration
  push(@headerContent, "class $implClassName;\n\n");

  # Class declaration
  push(@headerContent, "class $className : public $parentClassName {\n");
  push(@headerContent, "public:\n");
  
  # Constructor
  if ($dataNode->extendedAttributes->{"DoNotCache"}) {
      push(@headerContent, "    $className($implClassName*);\n");
  } else {
      push(@headerContent, "    $className(KJS::ExecState*, $implClassName*);\n");
  }
    
  # Destructor
  if (!$hasParent or $interfaceName eq "Document") {
    push(@headerContent, "    virtual ~$className();\n");
  }
  
  # Getters
  if ($numAttributes > 0) {
    push(@headerContent, "    virtual bool getOwnPropertySlot(KJS::ExecState*, const KJS::Identifier&, KJS::PropertySlot&);\n");
    push(@headerContent, "    KJS::JSValue* getValueProperty(KJS::ExecState*, int token) const;\n");
  }
  
  # Check if we have any writable properties
  my $hasReadWriteProperties = 0;
  foreach(@{$dataNode->attributes}) {
    if($_->type !~ /^readonly\ attribute$/) {
      $hasReadWriteProperties = 1;
    }
  }
  
  if ($hasReadWriteProperties) {
    push(@headerContent, "    virtual void put(KJS::ExecState*, const KJS::Identifier&, KJS::JSValue*, int attr = KJS::None);\n");
    push(@headerContent, "    void putValueProperty(KJS::ExecState*, int, KJS::JSValue*, int attr);\n");
  }
  
  # Class info
  push(@headerContent, "    virtual const KJS::ClassInfo* classInfo() const { return &info; }\n");
  push(@headerContent, "    static const KJS::ClassInfo info;\n");
  
  # Constructor object getter
  if ($numConstants ne 0) {
    push(@headerContent, "    static KJS::JSValue* getConstructor(KJS::ExecState*);\n")
  }

  # Attribute and function enums
  if ($numAttributes + $numFunctions > 0) {
    push(@headerContent, "    enum {\n")
  }
  
  if ($numAttributes > 0) {
    push(@headerContent, "        // Attributes\n        ");
    
    my $i = -1;
    foreach(@{$dataNode->attributes}) {
      my $attribute = $_;

      $i++;
      if((($i % 4) eq 0) and ($i ne 0)) {
        push(@headerContent, "\n        ");
      }

      my $value = ucfirst($attribute->signature->name) . "AttrNum";
      $value .= ", " if(($i < $numAttributes - 1));
      $value .= ", " if(($i eq $numAttributes - 1) and ($numFunctions ne 0));
      push(@headerContent, $value);
    }
  }
  
  if ($numFunctions > 0) {
    if ($numAttributes > 0) {
      push(@headerContent, "\n\n");
    }
    push(@headerContent,"        // Functions\n        ");

    $i = -1;
    foreach(@{$dataNode->functions}) {
      my $function = $_;

      $i++;
      if ((($i % 4) eq 0) and ($i ne 0)) {
        push(@headerContent, "\n        ");
      }

      my $value = ucfirst($function->signature->name) . "FuncNum";
      $value .= ", " if ($i < $numFunctions - 1);
      push(@headerContent, $value);
    }
  }
  
  if ($numAttributes + $numFunctions > 0) {
    push(@headerContent, "\n    };\n");
  }

  if (!$hasParent) {
    push(@headerContent, "    $implClassName* impl() const { return m_impl.get(); }\n");
    push(@headerContent, "private:\n");
    push(@headerContent, "    RefPtr<$implClassName> m_impl;\n");
  }
  
  if ($dataNode->extendedAttributes->{"IncludeAttributesInPropertyLookup"}) {
    push(@headerContent, "private:\n");
    push(@headerContent, "    static KJS::JSValue* attributeGetter(KJS::ExecState*, KJS::JSObject* originalObject, const KJS::Identifier& propertyName, const KJS::PropertySlot& slot);\n");
  }

  push(@headerContent, "};\n\n");
  
  if (!$hasParent) {
    push(@headerContent, "KJS::JSValue* toJS(KJS::ExecState*, $implClassName*);\n");
    push(@headerContent, "$implClassName* to${interfaceName}(KJS::JSValue*);\n\n");
  }

  # Add prototype declaration -- code adopted from the KJS_DEFINE_PROTOTYPE and KJS_DEFINE_PROTOTYPE_WITH_PROTOTYPE macros
  if ($numFunctions > 0 || $numConstants > 0) {
      push(@headerContent, "class ${className}Proto : public KJS::JSObject {\n");
      if (!$dataNode->extendedAttributes->{"DoNotCache"}) {
          push(@headerContent, "    friend KJS::JSObject* KJS_GCC_ROOT_NS_HACK cacheGlobalObject<${className}Proto>(KJS::ExecState*, const KJS::Identifier& propertyName);\n");
      }
      push(@headerContent, "public:\n");
      if ($dataNode->extendedAttributes->{"DoNotCache"}) {
          push(@headerContent, "    static KJS::JSObject* self();\n");
      } else {
          push(@headerContent, "    static KJS::JSObject* self(KJS::ExecState* exec);\n");
      }
      push(@headerContent, "    virtual const KJS::ClassInfo* classInfo() const { return &info; }\n");
      push(@headerContent, "    static const KJS::ClassInfo info;\n");
      push(@headerContent, "    bool getOwnPropertySlot(KJS::ExecState*, const KJS::Identifier&, KJS::PropertySlot&);\n");
      if ($numConstants ne 0) {
          push(@headerContent, "    KJS::JSValue* getValueProperty(KJS::ExecState*, int token) const;\n");
      }
      push(@headerContent, "protected:\n");
      if ($dataNode->extendedAttributes->{"DoNotCache"}) {
          push(@headerContent, "    ${className}Proto() { }\n");
      } else {
          push(@headerContent, "    ${className}Proto(KJS::ExecState* exec)\n");
          if ($hasParent && $parentClassName ne "KJS::DOMCSSRule" && $parentClassName ne "KJS::DOMNodeFilter") {
              push(@headerContent, "        : KJS::JSObject(${parentClassName}Proto::self(exec)) { }\n");
          } else {
              push(@headerContent, "        : KJS::JSObject(exec->lexicalInterpreter()->builtinObjectPrototype()) { }\n");
          }
      }
      push(@headerContent, "};\n\n");
  }
  
  push(@headerContent, "}\n\n#endif\n");
}

sub GenerateImplementation
{
  my $object = shift;
  my $dataNode = shift;
  
  my $interfaceName = $dataNode->name;
  my $className = "JS$interfaceName";
  my $implClassName = $interfaceName;
  
  my $hasLegacyParent = $dataNode->extendedAttributes->{"LegacyParent"};
  my $hasRealParent = @{$dataNode->parents} > 0;
  my $hasParent = $hasLegacyParent || $hasRealParent;
  my $parentClassName = GetParentClassName($dataNode);
  
  # - Add default header template
  @implContentHeader = split("\r", $headerTemplate);
  push(@implContentHeader, "\n");
  push(@implContentHeader,, "#include \"config.h\"\n");
  push(@implContentHeader, "#include \"$className.h\"\n\n");


  AddIncludesForType($interfaceName);

  @implContent = ();

  push(@implContent, "\nusing namespace KJS;\n\n");  
  push(@implContent, "namespace WebCore {\n\n");
  
  # - Add all attributes in a hashtable definition
  my $numAttributes = @{$dataNode->attributes};
  if ($numAttributes > 0) {
    my $hashSize = $numAttributes;
    my $hashName = $className . "Table";

    my @hashKeys = ();      # ie. 'insertBefore'
    my @hashValues = ();    # ie. 'JSNode::InsertBefore'
    my @hashSpecials = ();    # ie. 'DontDelete|Function'
    my @hashParameters = ();  # ie. '2'

    foreach my $attribute (@{$dataNode->attributes}) {
      my $name = $attribute->signature->name;
      push(@hashKeys, $name);
      
      my $value = $className . "::" . ucfirst($name) . "AttrNum";
      push(@hashValues, $value);

      my $special = "DontDelete";
      $special .= "|ReadOnly" if($attribute->type =~ /readonly/);
      push(@hashSpecials, $special);

      my $numParameters = "0";
      push(@hashParameters, $numParameters);      
    }

    $object->GenerateHashTable($hashName, $hashSize,
                            \@hashKeys, \@hashValues,
                             \@hashSpecials, \@hashParameters);
  }
  
  # - Add all constants
  my $numConstants = @{$dataNode->constants};
  if ($numConstants ne 0) {
    $hashSize = $numConstants;
    $hashName = $className . "ConstructorTable";

    @hashKeys = ();
    @hashValues = ();
    @hashSpecials = ();
    @hashParameters = ();
    
    foreach my $constant (@{$dataNode->constants}) {
      my $name = $constant->name;
      push(@hashKeys, $name);
     
      my $value = "${implClassName}::$name";
      push(@hashValues, $value);

      my $special = "DontDelete|ReadOnly";
      push(@hashSpecials, $special);

      my $numParameters = 0;
      push(@hashParameters, $numParameters); 
    }
    
    $object->GenerateHashTable($hashName, $hashSize,
                               \@hashKeys, \@hashValues,
                               \@hashSpecials, \@hashParameters);
                               
    # Add Constructor class
    push(@implContent, "class ${className}Constructor : public DOMObject {\n");
    push(@implContent, "public:\n");
    push(@implContent, "    ${className}Constructor(ExecState* exec) { " . 
                       "setPrototype(exec->lexicalInterpreter()->builtinObjectPrototype()); }\n");
    push(@implContent, "    virtual bool getOwnPropertySlot(ExecState*, const Identifier&, PropertySlot&);\n");
    push(@implContent, "    JSValue* getValueProperty(ExecState*, int token) const;\n");
    push(@implContent, "    virtual const ClassInfo* classInfo() const { return &info; }\n");
    push(@implContent, "    static const ClassInfo info;\n");    
    push(@implContent, "};\n\n");
    
    push(@implContent, "const ClassInfo ${className}Constructor::info = { \"${interfaceName}Constructor\", 0, " .
                       "&${className}ConstructorTable, 0 };\n\n");
                       
    push(@implContent, "bool ${className}Constructor::getOwnPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n{\n");
    push(@implContent, "    return getStaticValueSlot<${className}Constructor, DOMObject>" .
                       "(exec, &${className}ConstructorTable, this, propertyName, slot);\n}\n\n");

    push(@implContent, "JSValue* ${className}Constructor::getValueProperty(ExecState*, int token) const\n{\n");
    push(@implContent, "    // The token is the numeric value of its associated constant\n");
    push(@implContent, "    return jsNumber(token);\n}\n\n");
  }
  
  # - Add functions and constants to a hashtable definition
  my $numFunctions = @{$dataNode->functions};
  if ($numFunctions > 0 || $numConstants > 0) {
    $hashSize = $numFunctions + $numConstants;
    $hashName = $className . "ProtoTable";

    @hashKeys = ();
    @hashValues = ();
    @hashSpecials = ();
    @hashParameters = ();

    foreach my $constant (@{$dataNode->constants}) {
        my $name = $constant->name;
        push(@hashKeys, $name);
        
        my $value = "${implClassName}::$name";
        push(@hashValues, $value);
        
        my $special = "DontDelete|ReadOnly";
        push(@hashSpecials, $special);
        
        my $numParameters = 0;
        push(@hashParameters, $numParameters); 
    }
    
    foreach my $function (@{$dataNode->functions}) {
      my $name = $function->signature->name;
      push(@hashKeys, $name);
    
      my $value = $className . "::" . ucfirst($name) . "FuncNum";
      push(@hashValues, $value);
    
      my $special = "DontDelete|Function";
      push(@hashSpecials, $special);
    
      my $numParameters = @{$function->parameters};
      push(@hashParameters, $numParameters);
    }
    
    $object->GenerateHashTable($hashName, $hashSize,
                               \@hashKeys, \@hashValues,
                               \@hashSpecials, \@hashParameters);

    if($numFunctions > 0) {
        push(@implContent, "class ${className}ProtoFunc : public InternalFunctionImp {\n");
        push(@implContent, "public:\n");
        push(@implContent, "    ${className}ProtoFunc(ExecState* exec, int i, int len, const Identifier& name)\n");
        push(@implContent, "    : InternalFunctionImp(static_cast<FunctionPrototype*>(exec->lexicalInterpreter()->builtinFunctionPrototype()), name)\n");
        push(@implContent, "    , id(i)\n");
        push(@implContent, "    {\n");
        push(@implContent, "        put(exec, lengthPropertyName, jsNumber(len), DontDelete|ReadOnly|DontEnum);\n");
        push(@implContent, "    }\n");
        push(@implContent, "    virtual JSValue* callAsFunction(ExecState* exec, JSObject* thisObj, const List& args);\n");
        push(@implContent, "private:\n");
        push(@implContent, "    int id;\n");
        push(@implContent, "};\n\n");
    }

    push(@implContent, "const ClassInfo ${className}Proto::info = { \"$className\", 0, &${className}ProtoTable, 0 };\n\n");
    if ($dataNode->extendedAttributes->{"DoNotCache"}) {
        push(@implContent, "JSObject* ${className}Proto::self()\n");
        push(@implContent, "{\n");
        push(@implContent, "    return new ${className}Proto();\n");
        push(@implContent, "}\n\n");
    } else {
        push(@implContent, "JSObject* ${className}Proto::self(ExecState* exec)\n");
        push(@implContent, "{\n");
        push(@implContent, "    return ::cacheGlobalObject<${className}Proto>(exec, \"[[${className}.prototype]]\");\n");
        push(@implContent, "}\n\n");
    }
    push(@implContent, "bool ${className}Proto::getOwnPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n");
    push(@implContent, "{\n");
    if ($numConstants eq 0) {
        push(@implContent, "    return getStaticFunctionSlot<${className}ProtoFunc, JSObject>(exec, &${className}ProtoTable, this, propertyName, slot);\n");
    } elsif ($numFunctions eq 0) {
        push(@implContent, "    return getStaticValueSlot<${className}Proto, JSObject>(exec, &${className}ProtoTable, this, propertyName, slot);\n");
    } else {
        push(@implContent, "    return getStaticPropertySlot<${className}ProtoFunc, ${className}Proto, JSObject>(exec, &${className}ProtoTable, this, propertyName, slot);\n");
    }
    push(@implContent, "}\n\n");
    if ($numConstants ne 0) {
        push(@implContent, "JSValue* ${className}Proto::getValueProperty(ExecState*, int token) const\n{\n");
        push(@implContent, "    // The token is the numeric value of its associated constant\n");
        push(@implContent, "    return jsNumber(token);\n}\n\n");
    }
  }
  
  # - Initialize static ClassInfo object
  push(@implContent, "const ClassInfo $className" . "::info = { \"$interfaceName\", ");
  if ($hasParent) {
    push(@implContent, "&" .$parentClassName . "::info, ");
  } else {
    push(@implContent, "0, ");
  }
  
  if ($numAttributes > 0) {
    push(@implContent, "&${className}Table, ");
  } else {
    push(@implContent, "0, ")
  }
  push(@implContent, "0 };\n\n");
    
  # Constructor
  if ($dataNode->extendedAttributes->{"DoNotCache"}) {
      push(@implContent, "${className}::$className($implClassName* impl)\n");
      push(@implContent, "    : $parentClassName(impl)\n");
  } else {
      push(@implContent, "${className}::$className(ExecState* exec, $implClassName* impl)\n");
      if ($hasParent) {
          push(@implContent, "    : $parentClassName(exec, impl)\n");
      } else {
          push(@implContent, "    : m_impl(impl)\n");
      }
  }
  
  if ($dataNode->extendedAttributes->{"DoNotCache"}) {
      push(@implContent, "{\n    setPrototype(${className}Proto::self());\n}\n\n");
  } elsif ($numFunctions ne 0 || $numConstants ne 0) {
      push(@implContent, "{\n    setPrototype(${className}Proto::self(exec));\n}\n\n");
  } else {
      push(@implContent, "{\n}\n\n");    
  }
  
  # Destructor
  if (!$hasParent) {
    push(@implContent, "${className}::~$className()\n");
    push(@implContent, "{\n    ScriptInterpreter::forgetDOMObject(m_impl.get());\n}\n\n");    
  }

  # Document needs a special destructor because it's a special case for caching. It needs
  # its own special handling rather than relying on the caching that Node normally does.
  if ($interfaceName eq "Document") {
    push(@implContent, "${className}::~$className()\n");
    push(@implContent, "{\n    ScriptInterpreter::forgetDOMObject(static_cast<${implClassName}*>(m_impl.get()));\n}\n\n");    
  }
  
  # Attributes
  if ($numAttributes ne 0) {
    if ($dataNode->extendedAttributes->{"IncludeAttributesInPropertyLookup"}) {
      push(@implContent, getOwnPropertySlotIncludeAttributes($className, $parentClassName, $implClassName));
    } else {
      push(@implContent, "bool ${className}::getOwnPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n");
      push(@implContent, "{\n");
      push(@implContent, "    return getStaticValueSlot<$className, $parentClassName>(exec, &${className}Table, this, propertyName, slot);\n");
      push(@implContent, "}\n\n");
    }
  
    push(@implContent, "JSValue* ${className}::getValueProperty(ExecState *exec, int token) const\n{\n");
    push(@implContent, "    $implClassName* impl = static_cast<$implClassName*>(${className}::impl());\n\n");
    push(@implContent, "    switch (token) {\n");

    foreach my $attribute (@{$dataNode->attributes}) {
      my $name = $attribute->signature->name;
  
      if (!@{$attribute->getterExceptions}) {
        push(@implContent, "    case " . ucfirst($name) . "AttrNum:\n");
        push(@implContent, "        return " . NativeToJSValue($attribute->signature, "impl->$name()") . ";\n");
      } else {
        push(@implContent, "    case " . ucfirst($name) . "AttrNum: {\n");
        push(@implContent, "        ExceptionCode ec = 0;\n");
        push(@implContent, "        KJS::JSValue* result = " . NativeToJSValue($attribute->signature, "impl->$name(ec)") . ";\n");
        push(@implContent, "        setDOMException(exec, ec);\n");
        push(@implContent, "        return result;\n");
        push(@implContent, "    }\n");
      }
    }

    push(@implContent, "    }\n    return 0;\n}\n\n");
    
    # Check if we have any writable attributes
    my $hasReadWriteProperties = 0;
    foreach my $attribute (@{$dataNode->attributes}) {
      $hasReadWriteProperties = 1 if $attribute->type !~ /^readonly/;
    }
    if ($hasReadWriteProperties) {
      push(@implContent, "void ${className}::put(ExecState* exec, const Identifier& propertyName, JSValue* value, int attr)\n");
      push(@implContent, "{\n    lookupPut<$className, $parentClassName>" .
                         "(exec, propertyName, value, attr, &${className}Table, this);\n}\n\n");
                         
      push(@implContent, "void ${className}::putValueProperty(ExecState* exec, int token, JSValue* value, int /*attr*/)\n");
      push(@implContent, "{\n");
      push(@implContent, "    $implClassName* impl = static_cast<$implClassName*>(${className}::impl());\n\n");
      push(@implContent, "    switch (token) {\n");
      
      foreach my $attribute (@{$dataNode->attributes}) {
        if ($attribute->type !~ /^readonly/) {
          my $name = $attribute->signature->name;
          push(@implContent, "    case " . ucfirst($name) ."AttrNum: {\n");
          push(@implContent, "        ExceptionCode ec = 0;\n") if @{$attribute->setterExceptions};
          push(@implContent, "        impl->set" . ucfirst($name) . "(" . JSValueToNative($attribute->signature, "value"));
          push(@implContent, ", ec") if @{$attribute->setterExceptions};
          push(@implContent, ");\n");
          push(@implContent, "        setDOMException(exec, ec);\n") if @{$attribute->setterExceptions};
          push(@implContent, "    }\n");
          push(@implContent, "        break;\n");
        }
      }
      push(@implContent, "    }\n}\n\n");      
    }
  }

  if ($numConstants ne 0) {
    push(@implContent, "JSValue* ${className}::getConstructor(ExecState* exec)\n{\n");
    push(@implContent, "    return cacheGlobalObject<${className}Constructor>(exec, \"[[${interfaceName}.constructor]]\");\n");
    push(@implContent, "}\n");
  }    
  
  # Functions
  if($numFunctions ne 0) {
    push(@implContent, "JSValue* ${className}ProtoFunc::callAsFunction(ExecState* exec, JSObject* thisObj, const List& args)\n{\n");
    push(@implContent, "    if (!thisObj->inherits(&${className}::info))\n");
    push(@implContent, "      return throwError(exec, TypeError);\n\n");

    push(@implContent, "    $implClassName* impl = static_cast<$implClassName*>(static_cast<$className*>(thisObj)->impl());\n\n");
    
    
    push(@implContent, "    switch (id) {\n");
    foreach my $function (@{$dataNode->functions}) {      
      push(@implContent, "    case ${className}::" . ucfirst($function->signature->name) . "FuncNum: {\n");
      
      AddIncludesForType($function->signature->type);
      
      my $paramIndex = 0;
      my $functionString = "impl->" . $function->signature->name . "(";
      my $numParameters = @{$function->parameters};
      
      foreach my $parameter (@{$function->parameters}) {
        my $name = $parameter->name;
        push(@implContent, "        bool ${name}Ok;\n") if TypeCanFailConversion($parameter);
        push(@implContent, "        " . GetNativeType($parameter) . " $name = " . JSValueToNative($parameter, "args[$paramIndex]", TypeCanFailConversion($parameter) ? "${name}Ok" : undef) . ";\n");        
	if (TypeCanFailConversion($parameter)) {
	    push(@implContent, "        if (!${name}Ok) {\n");
	    push(@implContent, "            setDOMException(exec, TYPE_MISMATCH_ERR);\n");
	    push(@implContent, "            return jsUndefined();\n        }\n");
	}          
        
        # If a parameter is "an index", it should throw an INDEX_SIZE_ERR
        # exception        
        if ($parameter->extendedAttributes->{"IsIndex"}) {
          $implIncludes{"ExceptionCode.h"} = 1;
          push(@implContent, "        if ($name < 0) {\n");
          push(@implContent, "            setDOMException(exec, INDEX_SIZE_ERR);\n");
          push(@implContent, "            return jsUndefined();\n        }\n");          
        }
        
        $functionString .= ", " if $paramIndex;
        $functionString .= $name;

        $paramIndex++;
      }
  
      if (@{$function->raisesExceptions}) {
        $functionString .= ", " if $paramIndex;
        $functionString .= "ec";
        push(@implContent, "        ExceptionCode ec = 0;\n");
      }
      $functionString .= ")";
      
      if ($function->signature->type eq "void") {
        push(@implContent, "\n        $functionString;\n");
        push(@implContent, "        setDOMException(exec, ec);\n") if @{$function->raisesExceptions};
        push(@implContent, "        return jsUndefined();\n");
      } else {
        push(@implContent, "\n        KJS::JSValue* result = " . NativeToJSValue($function->signature, $functionString) . ";\n");
        push(@implContent, "        setDOMException(exec, ec);\n") if @{$function->raisesExceptions};
        push(@implContent, "        return result;\n");
      }

      push(@implContent, "    }\n");
    }
    push(@implContent, "    }\n");
    push(@implContent, "    return 0;\n");
    push(@implContent, "}\n")
  }
  
  if (!$hasParent) {
    push(@implContent, "KJS::JSValue* toJS(KJS::ExecState* exec, $implClassName* obj)\n");
    push(@implContent, "{\n");
    push(@implContent, "    return KJS::cacheDOMObject<$implClassName, $className>(exec, obj);\n");
    push(@implContent, "}\n");
    push(@implContent, "$implClassName* to${interfaceName}(KJS::JSValue* val)\n");
    push(@implContent, "{\n");
    push(@implContent, "    return val->isObject(&${className}::info) ? static_cast<$className*>(val)->impl() : 0;\n");
    push(@implContent, "}\n");
  }

  push(@implContent, "\n}\n");
}

sub GetNativeType
{
  my $signature = shift;
  
  my $type = $signature->type;
  
  if ($type eq "boolean") {
    return "bool";
  } elsif ($type eq "unsigned long") {
    if ($signature->extendedAttributes->{"IsIndex"}) {
      # Special-case index arguments because we need to check that
      # they aren't < 0.        
      return "int";
    } else {
      return "unsigned";
    } 
  } elsif ($type eq "long") {
    return "int";
  } elsif ($type eq "unsigned short") {
    return "unsigned short";
  } elsif ($type eq "float") {
    return "float";
  } elsif ($type eq "AtomicString") {
    return "AtomicString";
  } elsif ($type eq "DOMString") {
    return "String";
  } elsif ($type eq "Node" or
           $type eq "Element" or
           $type eq "Attr" or
           $type eq "DocumentType" or
           $type eq "Range") {
    return "${type}*";
  } elsif ($type eq "NodeFilter") {
      return "PassRefPtr<${type}>";
  } elsif ($type eq "CompareHow") {
    return "Range::CompareHow";
  } elsif ($type eq "EventTarget") {
    return "EventTargetNode*";
  } elsif ($type eq "DOMWindow") {
    return "DOMWindow*";
  } else {
    die "Don't know the native type of $type";
  }
}

sub TypeCanFailConversion
{
  my $signature = shift;
  
  my $type = $signature->type;

  if ($type eq "boolean") {
    return 0;
  } elsif ($type eq "unsigned long" or $type eq "long") {
    return 0; # or can it?
  } elsif ($type eq "unsigned short") {
    return 0; # or can it?
  } elsif ($type eq "CompareHow") {
    return 0; # or can it?
  } elsif ($type eq "float") {
    return 0;
  } elsif ($type eq "AtomicString") {
      return 0;
  } elsif ($type eq "DOMString") {
      return 0;
  } elsif ($type eq "Node") {
      return 0;
  } elsif ($type eq "Element") {
      return 0;
  } elsif ($type eq "Attr") {
      $implIncludes{"ExceptionCode.h"} = 1;
      return 1;
  } elsif ($type eq "DocumentType") {
      return 0;
  } elsif ($type eq "EventTarget") {
      return 0;
  }  elsif ($type eq "Range") {
      return 0;
  }  elsif ($type eq "NodeFilter") {
      return 0;
  } elsif ($type eq "DOMWindow") {
      return 0;
  } else {
    die "Don't know whether a JS value can fail conversion to type $type."
  }
}

sub JSValueToNative
{
  my $signature = shift;
  my $value = shift;
  my $okParam = shift;
  my $maybeOkParam = $okParam ? ", ${okParam}" : "";
  
  my $type = $signature->type;

  if ($type eq "boolean") {
    my $conv = $signature->extendedAttributes->{"ConvertUndefinedToTrue"};
    if (defined $conv) {
	return "valueToBooleanTreatUndefinedAsTrue(exec, $value)";
    } else {
	return "$value->toBoolean(exec)";
    }
  } elsif ($type eq "unsigned long" or $type eq "long") {
    return "$value->toInt32(exec)";
  } elsif ($type eq "unsigned short") {
    return "$value->toInt32(exec)";
  } elsif ($type eq "CompareHow") {
    return "static_cast<Range::CompareHow>($value->toInt32(exec))";
  } elsif ($type eq "float") {
    return "$value->toNumber(exec)";
  } elsif ($type eq "AtomicString") {
    return "$value->toString(exec)";
  } elsif ($type eq "DOMString") {
    if ($signature->extendedAttributes->{"ConvertNullToNullString"}) {
      return "valueToStringWithNullCheck(exec, $value)";
    } else {
      return "$value->toString(exec)";
    }
  } elsif ($type eq "Node") {
    $implIncludes{"kjs_dom.h"} = 1;
    return "toNode($value)";
  } elsif ($type eq "EventTarget") {
    $implIncludes{"kjs_dom.h"} = 1;
    return "toEventTargetNode($value)";
  }  elsif ($type eq "Attr") {
    $implIncludes{"kjs_dom.h"} = 1;
    return "toAttr($value${maybeOkParam})";
  } elsif ($type eq "DocumentType") {
      $implIncludes{"kjs_dom.h"} = 1;
      return "toDocumentType($value)";
  } elsif ($type eq "Range") {
      $implIncludes{"JSRange.h"} = 1;
      return "toRange($value)";
  } elsif ($type eq "Element") {
    $implIncludes{"kjs_dom.h"} = 1;
    return "toElement($value)";
  } elsif ($type eq "NodeFilter") {
    $implIncludes{"kjs_traversal.h"} = 1;
    return "toNodeFilter($value)";
  } elsif ($type eq "DOMWindow") {
    $implIncludes{"kjs_window.h"} = 1;
    return "toDOMWindow($value)";
  } else {
    die "Don't know how to convert a JS value of type $type."
  }
}

sub NativeToJSValue
{
  my $signature = shift;
  my $value = shift;
  
  my $type = $signature->type;
  
  if ($type eq "boolean") {
    return "jsBoolean($value)";
  } elsif ($type eq "long" or
           $type eq "unsigned long" or 
           $type eq "short" or 
           $type eq "unsigned short" or
           $type eq "float") {
    return "jsNumber($value)";
  } elsif ($type eq "DOMString") {
    my $conv = $signature->extendedAttributes->{"ConvertNullStringTo"};
    if (defined $conv) {
      if ($conv eq "Null") {
        return "jsStringOrNull($value)";
      } elsif ($conv eq "Undefined") {
        return "jsStringOrUndefined($value)";
      } elsif ($conv eq "False") {
        return "jsStringOrFalse($value)";
      } else {
        die "Unknown value for ConvertNullStringTo extended attribute";
      }
    } else {
      return "jsString($value)";
    }
  } elsif ($type eq "DOMImplementation") {
    $implIncludes{"kjs_dom.h"} = 1;
    $implIncludes{"JSDOMImplementation.h"} = 1;
    return "toJS(exec, $value)";
  } elsif ($type eq "Attr" or
           $type eq "CDATASection" or
           $type eq "Comment" or
           $type eq "Document" or
           $type eq "DocumentFragment" or
           $type eq "DocumentType" or
           $type eq "Element" or
           $type eq "EntityReference" or
           $type eq "HTMLDocument" or
           $type eq "Node" or
           $type eq "ProcessingInstruction" or
           $type eq "Text") {
    $implIncludes{"kjs_dom.h"} = 1;
    $implIncludes{"Comment.h"} = 1;
    $implIncludes{"CDATASection.h"} = 1;
    $implIncludes{"Node.h"} = 1;
    $implIncludes{"Element.h"} = 1;
    $implIncludes{"DocumentType.h"} = 1;
    return "toJS(exec, $value)";
  } elsif ($type eq "EventTarget") {
    $implIncludes{"kjs_dom.h"} = 1;
    $implIncludes{"EventTargetNode.h"} = 1;
    return "toJS(exec, $value)";
  } elsif ($type eq "Event") {
    $implIncludes{"kjs_events.h"} = 1;
    $implIncludes{"dom2_eventsimpl.h"} = 1;
    return "toJS(exec, $value)";
  } elsif ($type eq "NodeList" or $type eq "NamedNodeMap") {
    $implIncludes{"kjs_dom.h"} = 1;
    return "toJS(exec, $value)";
  } elsif ($type eq "CSSStyleSheet" or $type eq "StyleSheet" or $type eq "MediaList") {
    $implIncludes{"css_stylesheetimpl.h"} = 1;
    $implIncludes{"css_ruleimpl.h"} = 1;
    $implIncludes{"kjs_css.h"} = 1;
    return "toJS(exec, $value)";    
  } elsif ($type eq "StyleSheetList") {
    $implIncludes{"css_stylesheetimpl.h"} = 1;
    $implIncludes{"kjs_css.h"} = 1;
    return "toJS(exec, $value, impl)";    
  } elsif ($type eq "CSSRuleList") {
    $implIncludes{"css_ruleimpl.h"} = 1;
    return "toJS(exec, $value)";  
  } elsif ($type eq "CSSStyleDeclaration" or $type eq "Rect") {
    $implIncludes{"css_valueimpl.h"} = 1;
    $implIncludes{"kjs_css.h"} = 1;
    return "toJS(exec, $value)";
  } elsif ($type eq "RGBColor") {
    $implIncludes{"kjs_css.h"} = 1;
    return "getDOMRGBColor(exec, $value)";
  } elsif ($type eq "HTMLCanvasElement") {
    $implIncludes{"kjs_dom.h"} = 1;
    $implIncludes{"HTMLCanvasElement.h"} = 1;
    return "toJS(exec, $value)";
  } elsif ($type eq "CanvasGradient" or $type eq "Counter" or $type eq "Range") {
    $implIncludes{"JS$type.h"} = 1;
    return "toJS(exec, $value)";
  } elsif ($type eq "NodeIterator" or
	   $type eq "TreeWalker") {
    $implIncludes{"kjs_traversal.h"} = 1;
    return "toJS(exec, $value)";
  } elsif ($type eq "DOMWindow") {
    $implIncludes{"kjs_window.h"} = 1;
    return "toJS(exec, $value)";
  } elsif ($type eq "DOMObject") {
    $implIncludes{"JSCanvasRenderingContext2DBase.h"} = 1;
    return "toJS(exec, $value)";
  } else {
    die "Don't know how to convert a value of type $type to a JS Value";
  }
  
  die ("$value " . $signature->type);
}

# Internal Helper
sub GenerateHashTable
{
  my $object = shift;

  my $name = shift;
  my $size = shift;
  my $keys = shift;
  my $values = shift;
  my $specials = shift;
  my $parameters = shift;

  # Helpers
  my @table = ();
  my @links = ();

  my $maxDepth = 0;
  my $collisions = 0;
  my $savedSize = $size;

  # Collect hashtable information...
  my $i = 0;
  foreach(@{$keys}) {
    my $depth = 0;
    my $h = $object->GenerateHashValue($_) % $savedSize;

    while(defined($table[$h])) {
      if(defined($links[$h])) {
        $h = $links[$h];
        $depth++;
      } else {
        $collisions++;
        $links[$h] = $size;
        $h = $size;
        $size++;
      }
    }
  
    $table[$h] = $i;

    $i++;
    $maxDepth = $depth if($depth > $maxDepth);
  }

  # Ensure table is big enough (in case of undef entries at the end)
  if($#table + 1 < $size) {
    $#table = $size - 1;
  }

  # Start outputing the hashtables...
  my $nameEntries = "${name}Entries";
  $nameEntries =~ s/:/_/g;

  # first, build the string table
  my %soffset = ();
  if(($name =~ /Proto/) or ($name =~ /Constructor/)) {
    my $type = $name;
    my $implClass;

    if($name =~ /Proto/) {
      $type =~ s/Proto.*//;
      $implClass = $type; $implClass =~ s/Wrapper$//;
      push(@implContent, "/* Hash table for prototype */\n");
    } else {
      $type =~ s/Constructor.*//;
      $implClass = $type; $implClass =~ s/Constructor$//;
      push(@implContent, "/* Hash table for constructor */\n");
    }
  } else {
    push(@implContent, "/* Hash table */\n");
  }

  # Dump the hash table...
  push(@implContent, "\nstatic const HashEntry $nameEntries\[\] =\n\{\n");

  $i = 0;
  foreach $entry (@table) {
    if(defined($entry)) {
      my $key = @$keys[$entry];

      push(@implContent, "    \{ \"" . $key . "\"");
      push(@implContent, ", " . @$values[$entry]);
      push(@implContent, ", " . @$specials[$entry]);
      push(@implContent, ", " . @$parameters[$entry]);
      push(@implContent, ", ");

      if(defined($links[$i])) {
        push(@implContent, "&${nameEntries}[$links[$i]]" . " \}");
      } else {
        push(@implContent, "0 \}");
      }
    } else {
      push(@implContent, "    \{ 0, 0, 0, 0, 0 \}");
    }

    push(@implContent, ",") unless($i eq $size - 1);
    push(@implContent, "\n");

    $i++;
  }

  push(@implContent, "};\n\n");
  push(@implContent, "static const HashTable $name = \n");
  push(@implContent, "{\n    2, $size, $nameEntries, $savedSize\n};\n\n");
}

# Internal helper
sub GenerateHashValue
{
  my $object = shift;

  @chars = split(/ */, $_[0]);

  # This hash is designed to work on 16-bit chunks at a time. But since the normal case
  # (above) is to hash UTF-16 characters, we just treat the 8-bit chars as if they
  # were 16-bit chunks, which should give matching results

  my $EXP2_32 = 4294967296;

  my $hash = 0x9e3779b9;
  my $l    = scalar @chars; #I wish this was in Ruby --- Maks
  my $rem  = $l & 1;
  $l = $l >> 1;

  my $s = 0;

  # Main loop
  for (; $l > 0; $l--) {
    $hash   += ord($chars[$s]);
    my $tmp = (ord($chars[$s+1]) << 11) ^ $hash;
    $hash   = (($hash << 16)% $EXP2_32) ^ $tmp;
    $s += 2;
    $hash += $hash >> 11;
  }

  # Handle end case
  if ($rem !=0) {
    $hash += ord($chars[$s]);
    $hash ^= (($hash << 11)% $EXP2_32);
    $hash += $hash >> 17;
  }

  # Force "avalanching" of final 127 bits
  $hash ^= ($hash << 3);
  $hash += ($hash >> 5);
  $hash = ($hash% $EXP2_32);
  $hash ^= (($hash << 2)% $EXP2_32);
  $hash += ($hash >> 15);
  $hash = $hash% $EXP2_32;
  $hash ^= (($hash << 10)% $EXP2_32);
  
  # this avoids ever returning a hash code of 0, since that is used to
  # signal "hash not computed yet", using a value that is likely to be
  # effectively the same as 0 when the low bits are masked
  $hash = 0x80000000  if ($hash == 0);

  return $hash;
}

# Internal helper
sub WriteData
{
  if (defined($IMPL)) {
    # Write content to file.
    print $IMPL @implContentHeader;
  
    foreach my $implInclude (sort keys(%implIncludes)) {
      print $IMPL "#include \"$implInclude\"\n";
    }

    print $IMPL @implContent;
    close($IMPL);
    undef($IMPL);

    @implHeaderContent = "";
    @implContent = "";    
    %implIncludes = ();
  }

  if (defined($HEADER)) {
    # Write content to file.
    print $HEADER @headerContent;
    close($HEADER);
    undef($HEADER);

    @headerContent = "";
  }
}

sub getOwnPropertySlotIncludeAttributes
{
    my $className = shift;
    my $parentClassName = shift;
    my $implClassName = shift;
    
    my $implContent = "";
    
    $implContent .= "JSValue* ${className}::attributeGetter(ExecState* exec, JSObject* originalObject, const Identifier& propertyName, const PropertySlot& slot)\n";
    $implContent .= "{\n";
    $implContent .= "    ${className}* thisObj = static_cast<${className}*>(slot.slotBase());\n";
    $implContent .= "    return jsStringOrNull(static_cast<${implClassName}*>(thisObj->impl())->getAttributeNS(nullAtom, propertyName));\n";
    $implContent .= "}\n\n";

    $implContent .= "bool ${className}::getOwnPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n";
    $implContent .= "{\n";
    $implContent .= "    const HashEntry* entry = Lookup::findEntry(&${className}Table, propertyName);\n";
    $implContent .= "    if (entry) {\n";
    $implContent .= "        slot.setStaticEntry(this, entry, staticValueGetter<${className}>);\n";
    $implContent .= "        return true;\n";
    $implContent .= "    }\n\n";
    
    $implContent .= "    // We have to check in $parentClassName before giving access to attributes, otherwise\n";
    $implContent .= "    // properties like onload would return string (attribute) values instead of\n";
    $implContent .= "    // object (listener function) values.\n";
    $implContent .= "    if (${parentClassName}::getOwnPropertySlot(exec, propertyName, slot))\n";
    $implContent .= "        return true;\n\n";
    
    $implContent .= "    JSValue* proto = prototype();\n";
    $implContent .= "    if (proto->isObject() && static_cast<JSObject *>(proto)->hasProperty(exec, propertyName))\n";
    $implContent .= "        return false;\n";
    
    $implContent .= "    // FIXME: do we really want to do this attribute lookup thing? Mozilla doesn't do it,\n";
    $implContent .= "    // and it seems like it could interfere with XBL.\n";
    $implContent .= "    String attr = static_cast<Element*>(impl())->getAttributeNS(nullAtom, propertyName);\n";
    $implContent .= "    if (!attr.isNull()) {\n";
    $implContent .= "        slot.setCustom(this, attributeGetter);\n";
    $implContent .= "        return true;\n";
    $implContent .= "    }\n\n";
    
    $implContent .= "    return false;\n";
    $implContent .= "}\n\n";
    
    return $implContent;
}

1;
