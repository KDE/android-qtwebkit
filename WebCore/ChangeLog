2010-12-06  Andy Estes  <aestes@apple.com>

        Reviewed by Darin Adler.

        Marquee elements do not stop animating when scrollAmount is set to 0.
        https://bugs.webkit.org/show_bug.cgi?id=50434

        Test: fast/html/marquee-scrollamount.html

        * rendering/RenderMarquee.cpp:
        (WebCore::RenderMarquee::timerFired): Allow increment to be 0.

2010-12-06  Ryosuke Niwa  <rniwa@webkit.org>

        Unreviewed Leopard buildfix for r73380.

        * platform/graphics/ca/mac/PlatformCAAnimationMac.mm:
        (PlatformCAAnimation::setTimingFunctions):
        * platform/graphics/ca/mac/PlatformCALayerMac.mm:
        (PlatformCALayer::PlatformCALayer):

2010-12-06  Philippe Normand  <pnormand@igalia.com>

        Reviewed by Martin Robinson.

        [GStreamer] use ResourceHandle::setDefersLoading in WebKitWebSourceGStreamer
        https://bugs.webkit.org/show_bug.cgi?id=44157

        * platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp:
        (webKitWebSrcNeedDataMainCb):
        (webKitWebSrcEnoughDataMainCb): Replaced platform-specific code
        with cross-platform ResourceHandle::setDefersLoading calls.

2010-12-06  Ryosuke Niwa  <rniwa@webkit.org>

        Unreviewed Leopard build fix for r73388.

        * accessibility/AccessibilitySlider.cpp:
        (WebCore::AccessibilitySlider::maxValueForRange):
        (WebCore::AccessibilitySlider::minValueForRange):

2010-12-06  Ryosuke Niwa  <rniwa@webkit.org>

        Unreviewed build fix for Leopard after r73379.

        * platform/graphics/cg/GraphicsContextCG.cpp:
        (WebCore::GraphicsContext::setAllowsFontSmoothing):

2010-12-06  Nate Chapin  <japhet@chromium.org>

        Reviewed by Adam Barth.

        Make DocumentWriter a member of DocumentLoader
        instead of FrameLoader.
        https://bugs.webkit.org/show_bug.cgi?id=50489

        Refactor, no new tests.

        * bindings/ScriptControllerBase.cpp:
        (WebCore::ScriptController::executeIfJavaScriptURL):
        * dom/Document.cpp:
        (WebCore::Document::Document):
        (WebCore::Document::close):
        (WebCore::Document::lastModified):
        (WebCore::Document::finishedParsing):
        (WebCore::Document::initSecurityContext):
        (WebCore::Document::updateURLForPushOrReplaceState):
        * dom/Document.h:
        (WebCore::Document::setDocumentLoader):
        (WebCore::Document::loader):
        * dom/ProcessingInstruction.cpp:
        (WebCore::ProcessingInstruction::checkStyleSheet):
        * dom/ScriptElement.cpp:
        (WebCore::ScriptElement::scriptCharset):
        * html/HTMLLinkElement.cpp:
        (WebCore::HTMLLinkElement::process):
        * html/MediaDocument.cpp:
        (WebCore::MediaDocument::replaceMediaElementTimerFired):
        * html/PluginDocument.cpp:
        (WebCore::PluginDocumentParser::createDocumentStructure):
        * loader/DocumentLoader.cpp:
        (WebCore::DocumentLoader::DocumentLoader):
        (WebCore::DocumentLoader::finishedLoading):
        (WebCore::DocumentLoader::commitData):
        (WebCore::DocumentLoader::setupForReplaceByMIMEType):
        (WebCore::DocumentLoader::setFrame):
        * loader/DocumentLoader.h:
        (WebCore::DocumentLoader::writer):
        * loader/DocumentWriter.h:
        (WebCore::DocumentWriter::setFrame):
        * loader/FrameLoader.cpp:
        (WebCore::FrameLoader::FrameLoader):
        (WebCore::FrameLoader::init):
        (WebCore::FrameLoader::clear):
        (WebCore::FrameLoader::receivedFirstData):
        (WebCore::FrameLoader::transitionToCommitted):
        (WebCore::FrameLoader::open):
        (WebCore::FrameLoader::finishedLoadingDocument):
        (WebCore::FrameLoader::addExtraFieldsToRequest):
        * loader/FrameLoader.h:
        (WebCore::FrameLoader::notifier):
        * loader/cache/CachedResourceLoader.cpp:
        (WebCore::CachedResourceLoader::requestPreload):
        * platform/network/FormDataBuilder.cpp:
        (WebCore::FormDataBuilder::encodingFromAcceptCharset):
        * svg/graphics/SVGImage.cpp:
        (WebCore::SVGImage::dataChanged):

2010-12-06  Mark Rowe  <mrowe@apple.com>

        Build fix.

        * WebCore.xcodeproj/project.pbxproj: Don't force WebCore to build against the 10.5 SDK.
        That's just plain wrong.

2010-12-06  Chris Fleizach  <cfleizach@apple.com>

        Reviewed by Darin Adler.

        HTML5 Slider does not work correctly with VoiceOver
        https://bugs.webkit.org/show_bug.cgi?id=50505

        Address a few problems with the Mac implementation for the accessibility slider.
            1) The value indicator is not hit testable.
            2) The value indicator does not return an AXValue.
            3) In the slider, the min/max values are not correct when min/max attributes are not present.
            4) When you change the value with the keyboard, it doesn't send out the right notification.
            5) Sliders were returning AXValue and AXTopLevelUIElement attributes twice in their list of attributes.
 
        Test: platform/mac/accessibility/html-slider-indicator.html

        * accessibility/AccessibilityObject.cpp:
        (WebCore::AccessibilityObject::getAttribute):
            Use fastGetAttribute on Element, instead of getAttribute.
        * accessibility/AccessibilityObject.h:
        (WebCore::AccessibilityObject::isInputSlider):
        * accessibility/AccessibilityRenderObject.cpp:
        (WebCore::AccessibilityRenderObject::doAccessibilityHitTest):
        * accessibility/AccessibilitySlider.cpp:
        (WebCore::AccessibilitySlider::doAccessibilityHitTest):
        (WebCore::AccessibilitySlider::maxValueForRange):
        (WebCore::AccessibilitySlider::minValueForRange):
        * accessibility/AccessibilitySlider.h:
        (WebCore::AccessibilitySlider::isInputSlider):
        * accessibility/mac/AccessibilityObjectWrapper.mm:
        (-[AccessibilityObjectWrapper accessibilityAttributeNames]):
        (-[AccessibilityObjectWrapper accessibilityAttributeValue:]):
        * html/HTMLInputElement.cpp:
        (WebCore::HTMLInputElement::applyStep):

2010-12-06  David Hyatt  <hyatt@apple.com>

        Reviewed by Simon Fraser.

        Fix for https://bugs.webkit.org/show_bug.cgi?id=49220 <<rdar://problem/8644849>, REGRESSION: transforms now
        O(n^3) from pathological behavior in lowestPosition, rightmostPosition, leftmostPosition and topmostPosition.

        This patch throws out the lowest/rightmost/leftmost/topmostPosition functions and re-architects layout overflow
        in the engine to cache all the information required to properly handle scrolling.

        In the old code, there were two types of overflow: layout overflow and visual overflow.  The former could
        affect scrolling and the latter could not.  The distinction was largely meaningless, since layout overflow
        wasn't actually used to determine scroll width or scroll height.  It didn't propagate across self-painting layer
        boundaries either.  In the old code, the term visible overflow meant the union of the layout overflow and
        visual overflow rects.

        In the new code, the two types of overflow remain, but the distinction between the two is now clear.  Visual overflow
        is used purely for painting and hit testing checks and layout overflow is used specifically for scrolling.  It has
        been expanded to propagate across self-painting layers, to factor in relative positioning and transforms, and to
        work with writing modes.

        In order to minimize layout test changes, layers no longer incorporate right/bottom overflow into their width/height members.
        Doing so uncovered two bugs where left/top overflow was ignored (proof that even having layer dimensions is harmful).
        A render tree dump hack has been put into the code to keep this overflow dumping for the RenderView's layer, since otherwise
        a huge number of tests would change.

        Added fast/overflow/overflow-rtl-vertical.html to test vertical writing-mode overflow.  Existing tests cover the rest.

        * page/FrameView.cpp:
        (WebCore::FrameView::adjustViewSize):
        (WebCore::FrameView::forceLayoutForPagination):
        Changed to use RenderView's docTop/Left/Width/Height accessors, which simply grab the overflow and properly flip it
        to account for writing modes.

        * platform/graphics/IntRect.h:
        (WebCore::IntRect::shiftLeftEdgeTo):
        (WebCore::IntRect::shiftRightEdgeTo):
        (WebCore::IntRect::shiftTopEdgeTo):
        (WebCore::IntRect::shiftBottomEdgeTo):
        New helper functions for sliding the edge of a rectangle without moving any of the other three edges.

        * rendering/InlineBox.h:
        (WebCore::InlineBox::frameRect):
        frameRect is a helper for obtaining the x, y, width, height of an InlineBox as an IntRect.

        * rendering/InlineFlowBox.cpp:
        (WebCore::InlineFlowBox::placeBoxesInInlineDirection):
        All of the overflow setting in the inline direction has been removed from this function.  All line overflow is computed
        at once now in a single function: computeOverflow.

        (WebCore::InlineFlowBox::addBoxShadowVisualOverflow):
        (WebCore::InlineFlowBox::addTextBoxVisualOverflow):
        (WebCore::InlineFlowBox::addReplacedChildOverflow):
        Helper for propagating overflow from specific types of children that occur on a line into the InlineFlowBox's overflow.

        (WebCore::InlineFlowBox::computeOverflow):
        The new function that computes both horizontal and vertical overflow for a line box.

        (WebCore::InlineFlowBox::setLayoutOverflow):
        (WebCore::InlineFlowBox::setVisualOverflow):
        (WebCore::InlineFlowBox::setOverflowFromLogicalRects):
        New functions that set the overflow computed by computeOverflow.  These replace setBlockDirectionOverflowPositions
        and setInlineDirectionOverflowPositions.  They essentially do the same thing, but they operate on rectangles.

        (WebCore::InlineFlowBox::nodeAtPoint):
        (WebCore::InlineFlowBox::paint):
        Changed to use visual overflow instead of visible overflow.  (Visible overflow as a union of layout and visual
        overflow is no longer necessary, since visual overflow is now equivalent to the old visible overflow concept.)

        * rendering/InlineFlowBox.h:
        (WebCore::InlineFlowBox::logicalLayoutOverflowRect):
        (WebCore::InlineFlowBox::logicalVisualOverflowRect):
        Helpers for obtaining logical overflow rectangles, since lines compute their overflow in logical terms before
        converting to block coordinates at the end.

        * rendering/RenderBlock.cpp:
        (WebCore::RenderBlock::layoutBlock):
        (WebCore::RenderBlock::addOverflowFromChildren):
        (WebCore::RenderBlock::computeOverflow):
        (WebCore::RenderBlock::addOverflowFromFloats):
        (WebCore::RenderBlock::addOverflowFromPositionedObjects):
        Blocks now have a computeOverflow function called at the end of layout that adds in all the types of overflow.  The addOverflowFromChildren
        method is virtual so that RenderListItem and RenderTable can subclass it.  RenderListItem has to position its list marker and
        propagate marker overflow up, and RenderTable adds in overflow from its sections.

        (WebCore::RenderBlock::layoutOnlyPositionedObjects):
        (WebCore::RenderBlock::layoutPositionedObjects):
        When only positioned objects lay out, overflow must still be recomputed.  The refactoring of overflow computation into a single
        callable method: computeOverflow, makes it possible for this to be done easily.

        (WebCore::RenderBlock::paint):
        visible -> visual.

        (WebCore::RenderBlock::addOverhangingFloats):
        The propagation of float overflow has changed substantially.  The basic rules are:
            (1) The float must be in our floating objects list to contribute to overflow.
            (2) The float must be a descendant to contribute to overflow.
            (3) The block must have the outermost list that contains the float, or it has a self-painting layer and
                so the float needs to be included in its overflow.

        (WebCore::RenderBlock::nodeAtPoint):
        visible -> visual.

        (WebCore::RenderBlock::layoutColumns):
        Remove column overflow computation from layoutColumns and move it to computeOverflow.

        (WebCore::RenderBlock::adjustLinePositionForPagination):
        visible -> visual.

        * rendering/RenderBlock.h:
        (WebCore::RenderBlock::scrollbarsChanged):
        Added a new virtual method used by table cells when scrollbars in an overflow:auto/scroll table cell come and go.

        * rendering/RenderBlockLineLayout.cpp:
        (WebCore::RenderBlock::layoutInlineChildren):
        (WebCore::RenderBlock::determineStartPosition):
        (WebCore::RenderBlock::matchedEndLine):
        (WebCore::RenderBlock::addOverflowFromInlineChildren):
        (WebCore::RenderBlock::beforeSideVisualOverflowForLine):
        (WebCore::RenderBlock::afterSideVisualOverflowForLine):
        visible -> visual.

        * rendering/RenderBox.cpp:
        (WebCore::RenderBox::scrollWidth):
        (WebCore::RenderBox::scrollHeight):
        Patched to use layoutOverflow functions instead of the old rightmost/leftmostPosition functions.

        (WebCore::RenderBox::paintRootBoxDecorations):
        Use docLeft and docTop here, so that writing modes are handled.

        (WebCore::RenderBox::clippedOverflowRectForRepaint):
        visible -> visual.

        (WebCore::RenderBox::addOverflowFromChild):
        (WebCore::RenderBox::addLayoutOverflow):
        (WebCore::RenderBox::addVisualOverflow):
        (WebCore::RenderBox::logicalVisualOverflowRectForPropagation):
        (WebCore::RenderBox::visualOverflowRectForPropagation):
        (WebCore::RenderBox::logicalLayoutOverflowRectForPropagation):
        (WebCore::RenderBox::layoutOverflowRectForPropagation):
        * rendering/RenderBox.h:
        The new overflow system for boxes.  Layout overflow now crosses self-painting layer boundaries and adjusts child boxes
        for transforms, relative positioning and writing mode differences.

        (WebCore::RenderBox::layoutOverflowRect):
        (WebCore::RenderBox::topLayoutOverflow):
        (WebCore::RenderBox::bottomLayoutOverflow):
        (WebCore::RenderBox::leftLayoutOverflow):
        (WebCore::RenderBox::rightLayoutOverflow):
        Changed the default rectangle for layout overflow to be the client box to match the scrollable areas of overflow regions.

        (WebCore::RenderBox::clientLogicalBottom):
        New helper for obtaining the logical bottom of the client box.

        (WebCore::RenderBox::clientBoxRect):
        New helper for obtaining the clientLeft/Top/Width/Height box.

        * rendering/RenderBoxModelObject.h:
        (WebCore::RenderBoxModelObject::relativePositionLogicalOffset):
        Helper for obtaining the relative position offset transposed for vertical writing modes.  Used by line overflow.

        * rendering/RenderFlexibleBox.cpp:
        (WebCore::RenderFlexibleBox::layoutBlock):
        Changed flexible boxes to just call the base class computeOverflow method.

        * rendering/RenderInline.cpp:
        (WebCore::RenderInline::linesVisualOverflowBoundingBox):
        (WebCore::RenderInline::clippedOverflowRectForRepaint):
        visible -> visual.

        * rendering/RenderInline.h:
        * rendering/RenderLayer.cpp:
        (WebCore::RenderLayer::updateLayerPosition):
        Changed layers to no longer incorporate right/bottom overflow into width/height.  This is the reason many layout
        tests change.  (Not doing this makes the layout test changes far worse, since overflow propagates across self-painting
        layers now.)

        (WebCore::RenderLayer::overflowTop):
        (WebCore::RenderLayer::overflowBottom):
        (WebCore::RenderLayer::overflowLeft):
        (WebCore::RenderLayer::overflowRight):
        overflowTop/Bottom/Left/Right return overflow that accounts for writing modes, i.e., purely physical overflow that can be used
        to set up the scroll area.

        (WebCore::RenderLayer::computeScrollDimensions):
        Drastically simplified this method now that overflowTop/Bottom/Left/Right just do the right thing regarding unreachable overflow.

        (WebCore::RenderLayer::updateScrollInfoAfterLayout):
        Make sure to explicitly set the vertical scrollbar's position just as we did with horizontal scrollbars, so that clamping to the
        bottom works.

        (WebCore::performOverlapTests):
        (WebCore::RenderLayer::paintLayer):
        Fix a bug in performOverlapTests.  It incorrectly used the layer's bounds, and so it didn't account for left/top overflow out
        of the layer (see why I hate layers even having dimensions?).  Changed it to use the bounding box of the layer instead.

        (WebCore::RenderLayer::hitTest):
        Fix a bug in hit testing.  It incorrectly used the root layer's bounds as the limit of the hit test, and so it didn't account
        for left/top overflow in a ScrollView (hate hate hate layers having dimensions).  I changed it to use the hit test rect instead,
        so that the damage rect never stops the point from being tested (unless the hit test request says not to ignore clipping).

        (WebCore::RenderLayer::localBoundingBox):
        visible -> visual.

        * rendering/RenderLayer.h:
        Added the new overflowTop/Left/Right/Bottom accessors.

        * rendering/RenderLineBoxList.cpp:
        (WebCore::RenderLineBoxList::anyLineIntersectsRect):
        (WebCore::RenderLineBoxList::lineIntersectsDirtyRect):
        (WebCore::RenderLineBoxList::paint):
        (WebCore::RenderLineBoxList::hitTest):
        visible -> visual.

        * rendering/RenderListItem.cpp:
        (WebCore::RenderListItem::addOverflowFromChildren):
        (WebCore::RenderListItem::positionListMarker):
        * rendering/RenderListItem.h:
        RenderListItem now positions the list marker when computing its overflow, since the marker propagates overflow back up to the list item.

        * rendering/RenderListMarker.cpp:
        (WebCore::RenderListMarker::paint):
        visible -> visual.

        * rendering/RenderMarquee.cpp:
        (WebCore::RenderMarquee::computePosition):
        Changed to use overflow functions instead of rightmost/lowestPosition.

        * rendering/RenderMedia.cpp:
        * rendering/RenderMedia.h:
        Removed the lowest/topmost/rightmost/leftmostPosition functions, since control overflow is handled properly already.

        * rendering/RenderOverflow.h:
        (WebCore::RenderOverflow::RenderOverflow):
        (WebCore::RenderOverflow::setLayoutOverflow):
        (WebCore::RenderOverflow::setVisualOverflow):
        Add new setters for layout and visual overflow as rects.

        * rendering/RenderReplaced.cpp:
        (WebCore::RenderReplaced::shouldPaint):
        (WebCore::RenderReplaced::clippedOverflowRectForRepaint):
        visible -> visual.

        * rendering/RenderRubyRun.cpp:
        (WebCore::RenderRubyRun::layout):
        Call computeOverflow to recompute our overflow information after we adjust the ruby.

        * rendering/RenderTable.cpp:
        (WebCore::RenderTable::layout):
        (WebCore::RenderTable::addOverflowFromChildren):
        (WebCore::RenderTable::paint):
        * rendering/RenderTable.h:
        Move section overflow propagation into addOverflowFromChildren, and change RenderTable to just call computeOverflow.

        * rendering/RenderTableCell.cpp:
        (WebCore::RenderTableCell::clippedOverflowRectForRepaint):
        visible -> visual.

        (WebCore::RenderTableCell::scrollbarsChanged):
        Adding unreachable overflow support (something that in the old code only existed for positioned objects in the root view) exposed
        a bug in table layout.  If scrollbars are added during the layout that occurs after intrinsic padding was incorporated into the
        cell, then the cell won't lay out properly the second time (after the scrollbars have been added).  We have to adjust the intrinsic
        padding accounting for the presence of the new scrollbar so the second layout will get the right dimensions.

        * rendering/RenderTableCell.h:
        (WebCore::RenderTableCell::hasVisualOverflow):
        visible -> visual.

        * rendering/RenderTableSection.cpp:
        (WebCore::RenderTableSection::layoutRows):
        * rendering/RenderTableSection.h:
        visible -> visual.  Removed the leftmost/rightmost/topmost/bottommostPosition functions.

        * rendering/RenderTreeAsText.cpp:
        (WebCore::writeLayers):
        Added a hack to render tree dumping to include right/bottom overflow for the root layer only.  This keeps a zillion layout tests
        from failing.

        * rendering/RenderView.cpp:
        (WebCore::RenderView::layout):
        (WebCore::RenderView::docTop):
        (WebCore::RenderView::docBottom):
        (WebCore::RenderView::docLeft):
        (WebCore::RenderView::docRight):
        * rendering/RenderView.h:
        (WebCore::RenderView::docHeight):
        (WebCore::RenderView::docWidth):
        RenderView now uses docLeft/Top/Height/Width functions, which are just overflow queries that account for writing modes.  These methods
        are now the preferred way to query for the physical dimensions of a document.

        * rendering/RootInlineBox.cpp:
        (WebCore::RootInlineBox::addHighlightOverflow):
        Changed to call setOverflowFromLogicalRects instead of the block/inline position functions.

        (WebCore::RootInlineBox::alignBoxesInBlockDirection):
        Remove the computation of block direction overflow, since it now all happens at once after the line is built.

        (WebCore::RootInlineBox::paddedLayoutOverflowRect):
        * rendering/RootInlineBox.h:
        Added a new helper function for incorporating the end padding into a line.  This end padding also includes the single pixel for a caret
        in LTR if needed.

2010-12-06  Chris Marrin  <cmarrin@apple.com>

        Reviewed by Simon Fraser.

        Share code between Mac (CA) and Windows (CACF) GraphicsLayer implementations
        https://bugs.webkit.org/show_bug.cgi?id=49388

        Replaced GraphicsLayerMac with GraphicsLayerCA. GraphicsLayerCA is essentially 
        identical to GraphicsLayerMac, but replaces all the CoreAnimation specific calls 
        with calls to PlatformCALayer and PlatformCAAnimation. This makes GraphicsLayerCA 
        platform neutral as long as implementations of those two classes are available. 
        Added implementations in PlatformCALayerMac and PlatformCAAnimationMac. Also got 
        rid of GraphicsLayer::nativeLayer() and replaced it with GraphicsLayer::platformLayer() 
        to avoid confusion since both names were used to refer to the same thing. 

        This patch is only for Mac. Windows implementation has not changed.

        * WebCore.xcodeproj/project.pbxproj:
        * platform/graphics/GraphicsLayer.h:
        * platform/graphics/ca/GraphicsLayerCA.cpp: Copied from WebCore/platform/graphics/ca/GraphicsLayerCA.cpp.
        * platform/graphics/ca/GraphicsLayerCA.h: Copied from WebCore/platform/graphics/ca/GraphicsLayerCA.h.
        * platform/graphics/ca/PlatformCAAnimation.h: Copied from WebCore/platform/graphics/ca/PlatformCAAnimation.h.
        * platform/graphics/ca/PlatformCALayer.h: Copied from WebCore/platform/graphics/ca/PlatformCALayer.h.
        * platform/graphics/ca/mac/PlatformCAAnimationMac.mm: Copied from WebCore/platform/graphics/ca/mac/PlatformCAAnimationMac.mm.
        (toCAMediaTimingFunction):
        * platform/graphics/ca/mac/PlatformCALayerMac.mm: Copied from WebCore/platform/graphics/ca/mac/PlatformCALayerMac.mm.
        (PlatformCALayer::PlatformCALayer):
        * platform/graphics/chromium/GraphicsLayerChromium.cpp:
        * platform/graphics/chromium/GraphicsLayerChromium.h:
        * platform/graphics/mac/GraphicsLayerMac.h: Removed.
        * platform/graphics/mac/GraphicsLayerMac.mm: Removed.
        * platform/graphics/mac/WebLayer.h:
        * platform/graphics/mac/WebLayer.mm:
        (-[WebLayer setNeedsDisplay]):
        (-[WebLayer setNeedsDisplayInRect:]):
        (-[WebLayer display]):
        (-[WebLayer drawInContext:]):
        * platform/graphics/mac/WebTiledLayer.h:
        * platform/graphics/mac/WebTiledLayer.mm:
        (-[WebTiledLayer setNeedsDisplay]):
        (-[WebTiledLayer setNeedsDisplayInRect:]):
        (-[WebTiledLayer display]):
        (-[WebTiledLayer drawInContext:]):
        * platform/graphics/qt/GraphicsLayerQt.cpp:
        (WebCore::GraphicsLayerQtImpl::flushChanges):
        * platform/graphics/qt/GraphicsLayerQt.h:
        * platform/graphics/win/GraphicsLayerCACF.cpp:
        * platform/graphics/win/GraphicsLayerCACF.h:

2010-12-06  Simon Fraser  <simon.fraser@apple.com>

        Reviewed by Dan Bernstein.

        Font antialiasing (smoothing) changes when elements are rendered into compositing layers
        https://bugs.webkit.org/show_bug.cgi?id=23364

        Text rendered by Core Graphics over a transparent background looks bad because of 
        font smoothing, so turn off smoothing when rendering text into compositing layers.

        * platform/graphics/GraphicsContext.h:
        * platform/graphics/cg/GraphicsContextCG.cpp:
        (WebCore::GraphicsContext::setAllowsFontSmoothing):
        * platform/graphics/mac/WebLayer.mm:
        (drawLayerContents):

2010-12-06  Patrick Gansterer  <paroga@webkit.org>

        Reviewed by Andreas Kling.

        [WINCE] Add build system
        https://bugs.webkit.org/show_bug.cgi?id=50522

        * CMakeListsWinCE.txt: Added.

2010-12-06  Chris Fleizach  <cfleizach@apple.com>

        Reviewed by Oliver Hunt.

        AX does not support HTML5 "required"
        https://bugs.webkit.org/show_bug.cgi?id=50507

        Test: platform/mac/accessibility/html5-required-attribute.html

        * accessibility/AccessibilityRenderObject.cpp:
        (WebCore::AccessibilityRenderObject::isRequired):

2010-12-06  Alejandro G. Castro  <alex@igalia.com>

        Reviewed by Martin Robinson.

        [GTK] using shadows leaks memory
        https://bugs.webkit.org/show_bug.cgi?id=50541

        Fixed leaks in the shadow code.
        * platform/graphics/cairo/CairoUtilities.cpp:
        (WebCore::drawPatternToCairoContext): adoptRef instead of just
        getting a new reference.
        * platform/graphics/cairo/GraphicsContextCairo.cpp:
        (WebCore::drawPathShadow): handle cairo_path_t with smart
        pointers.

2010-12-06  Yury Semikhatsky  <yurys@chromium.org>

        Reviewed by Pavel Feldman.

        [v8] Web Inspector: remove duplicate code for capturing stack trace
        https://bugs.webkit.org/show_bug.cgi?id=50461

        No new tests. Covered with existing inspector tests.

        * bindings/js/ScriptCallStackFactory.cpp:
        (WebCore::createScriptCallStack):
        * bindings/js/ScriptCallStackFactory.h:
        * bindings/v8/ScriptCallStackFactory.cpp:
        (WebCore::toScriptCallFrame):
        (WebCore::toScriptCallFramesVector):
        (WebCore::createScriptCallStack):
        * bindings/v8/ScriptCallStackFactory.h:
        * bindings/v8/V8ConsoleMessage.cpp:
        (WebCore::V8ConsoleMessage::handler):
        * inspector/ScriptCallFrame.cpp:
        (WebCore::ScriptCallFrame::ScriptCallFrame):
        (WebCore::ScriptCallFrame::isEqual):
        (WebCore::ScriptCallFrame::buildInspectorObject):
        * inspector/ScriptCallFrame.h:
        (WebCore::ScriptCallFrame::sourceURL):
        * inspector/ScriptCallStack.h:
        * inspector/TimelineRecordFactory.cpp:
        (WebCore::TimelineRecordFactory::createGenericRecord):
        * inspector/front-end/ConsoleView.js:
        (WebInspector.ConsoleMessage.prototype._populateStackTraceTreeElement):

== Rolled over to ChangeLog-2010-12-06 ==
