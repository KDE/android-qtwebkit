#!/usr/bin/perl -w

# Copyright (C) 2005, 2006 Apple Computer, Inc.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer. 
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution. 
# 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
#     its contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission. 
#
# THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Simplified and improved "svn diff" script for WebKit Open Source Project, used to make patches.

# Differences from standard "svn diff":
#
#   Uses the real diff, not svn's built-in diff.
#   Always passes "-p" to diff so it will try to include function names.
#   Handles binary files (encoded as a base64 chunk of text).
#   Sorts the diffs alphabetically by text files, then binary files.
#
# Missing features:
#
#   Handle moved files.

use strict;

use Config;
use Cwd;
use File::Basename;
use File::Spec;
use File::stat;
use Getopt::Long;
use MIME::Base64;
use POSIX qw(:errno_h);
use Time::gmtime;

my $startDir = getcwd();
my %paths;

# Create list of paths to diff.
if (!@ARGV) {
    $paths{"."} = 1;
} else {
    for my $file (@ARGV) {
        die "can't handle absolute paths like \"$file\"\n" if File::Spec->file_name_is_absolute($file);
        die "can't handle empty string path\n" if $file eq "";
        die "can't handle path with single quote in the name like \"$file\"\n" if $file =~ /'/; # ' (keep Xcode syntax highlighting happy)

        my $untouchedFile = $file;

        $file = canonicalizePath($file);

        die "can't handle paths with .. like \"$untouchedFile\"\n" if $file =~ m|/\.\./|;

        $paths{$file} = 1;
    }

    if ($paths{"."}) {
        %paths = ();
        $paths{"."} = 1;
    } else {
        # Remove any paths that also have a parent listed.
        for my $path (keys %paths) {
            for (my $parent = dirname($path); $parent ne '.'; $parent = dirname($parent)) {
                if ($paths{$parent}) {
                    delete $paths{$path};
                    last;
                }
            }
        }
    }
}

# Generate a list of files requiring diffs
my %textFiles;
my %binaryFiles;
for my $path (keys %paths) {
    generateFileList($path, \%textFiles, \%binaryFiles);
}

# Generate the diff for text files, then binary files, for easy reviewing
for my $file (sort keys %textFiles) {
    generateDiff($file);
}
for my $file (sort keys %binaryFiles) {
    generateDiff($file);
}

exit 0;


sub canonicalizePath
{
    my ($file) = @_;

    # Remove extra slashes and '.' directories in path
    $file = File::Spec->canonpath($file);

    # Remove '..' directories in path
    my @dirs = ();
    foreach my $dir (File::Spec->splitdir($file)) {
        if ($dir eq '..' && $#dirs >= 0 && $dirs[$#dirs] ne '..') {
            pop(@dirs);
        } else {
            push(@dirs, $dir);
        }
    }
    return ($#dirs >= 0) ? File::Spec->catdir(@dirs) : ".";
}

sub generateDiff
{
    my ($file) = @_;
    my $errors = "";
    my $isBinary;
    my $lastLine;
    open DIFF, "svn diff --diff-cmd diff -x -uNp '$file' |" or die;
    while (<DIFF>) {
        $isBinary = 1 if (/^Cannot display: file marked as a binary type\.$/);
        print;
        $lastLine = $_;
    }
    close DIFF;
    print "\n" if ($isBinary && $lastLine =~ m/\S+/);
    outputBinaryContent($file) if ($isBinary);
    print STDERR $errors;
}

sub generateFileList
{
    my ($path, $textFiles, $binaryFiles) = @_;
    my $indexPath;
    my $isBinary;
    open DIFF, "svn diff --diff-cmd diff -x -uNp '$path' |" or die;
    while (<DIFF>) {
        if (/^Index: (.*)/) {
            my $newIndexPath = $1;
            if ($indexPath) {
                if ($isBinary) {
                    $binaryFiles->{$indexPath} = 1;
                } else {
                    $textFiles->{$indexPath} = 1;
                }
            }
            $indexPath = $newIndexPath;
            $isBinary = 0;
        }
        if (/^Cannot display: file marked as a binary type\.$/) {
            $isBinary = 1;
        }
    }
    close DIFF;
    # Handle last patch
    if ($indexPath) {
        if ($isBinary) {
            $binaryFiles->{$indexPath} = 1;
        } else {
            $textFiles->{$indexPath} = 1;
        }
    }
}

sub outputBinaryContent
{
    my ($path) = @_;
    # Deletion
    return if (! -e $path);
    # Addition or Modification
    my $buffer;
    open BINARY, $path  or die;
    while (read(BINARY, $buffer, 60*57)) {
        print encode_base64($buffer);
    }
    close BINARY;
    print "\n";
}

