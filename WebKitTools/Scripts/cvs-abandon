#!/usr/bin/perl -w

# Copyright (C) 2005 Apple Computer, Inc.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer. 
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution. 
# 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
#     its contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission. 
#
# THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Figure out the underlying cvs versions.
# Overwrite each file with the underlying cvs version.

use strict;
use Getopt::Long;

my $verbose = 0;
GetOptions("verbose|v!" => \$verbose);

my @changedFiles = ();
my @addedFiles = ();
my @removedFiles = ();

print STDERR "Running cvs -n update to find changed, added, or removed files.\n" if $verbose;
open UPDATE, "cvs -qn update @ARGV 2> /dev/stdout |" or die "The cvs update failed: $!.\n";
while (<UPDATE>) {
    if (/^[CM] (.+)$/) {
        print STDERR "Found changed file $1.\n" if $verbose;
        push @changedFiles, $1;
    } elsif (/^A (.+)$/) {
        print STDERR "Found added file: $1\n" if $verbose;
        push @addedFiles, $1;
    } elsif (/^R (.+)$/) {
        print STDERR "Found removed file: $1\n" if $verbose;
        push @removedFiles, $1;
    }

    print unless /^[A-Z] ./ || /^cvs server: New directory/;
}
close UPDATE;

my $startDir = `pwd`;
chomp $startDir;

sub getDirAndBase
{
    my ($file) = @_;
    return ($1, $2) if $file =~ m|^(.+)/([^/]+)$|;
    $file !~ m|/| or die "Could not parse file name $file.\n";
    return (".", $file);
}

for my $file (@changedFiles) {
    my ($dir, $base) = getDirAndBase($file);

    my $version = "";
    open ENTRIES, "$dir/CVS/Entries" or die "Could not open $dir/CVS/Entries.\n";
    while (<ENTRIES>) {
        $version = $1 if m|^/$base/([.0-9]+)/|;
    }
    close ENTRIES;
    $version or die "Could not find version for $file.\n";
    
    print STDERR "Reverting file $file to version $version.\n" if $verbose;
    chdir $dir or die;
    system "cvs -q update -r $version -p $base > $base" and die "cvs update failed on $file.\n";
    chdir $startDir or die;
}

for my $file (@removedFiles) {
    my ($dir, $base) = getDirAndBase($file);

    print STDERR "Re-adding file $file.\n" if $verbose;
    chdir $dir or die;
    system "cvs", "add", $base and die "cvs add failed on $file.\n";
    chdir $startDir or die;
}

for my $file (@addedFiles) {
    my ($dir, $base) = getDirAndBase($file);

    print STDERR "Removing file $file.\n" if $verbose;
    chdir $dir or die;
    system "cvs", "rm", "-f", $base and die "cvs rm failed on $file.\n";
    chdir $startDir or die;
}
