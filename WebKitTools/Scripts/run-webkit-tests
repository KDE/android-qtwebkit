#!/usr/bin/perl -w

# Copyright (C) 2005, 2006 Apple Computer, Inc.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer. 
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution. 
# 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
#     its contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission. 
#
# THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Script to run the Web Kit Open Source Project layout tests.

use strict;
use IPC::Open2;
use Getopt::Long;
use File::Path;
use File::Copy;
use FindBin;
use Cwd;
use lib $FindBin::Bin;
use webkitdirs;
use Time::HiRes qw(time);

# Run all the tests passed in on the command line.
# If no tests are passed, find all the .html, .xml, .xhtml (and svg) files in the test directory.

# Run each text.
# Compare against the existing file xxx-expected.txt.
# If there is a mismatch, generate xxx-actual.txt and xxx-diffs.txt.

# At the end, report:
#   the number of tests that got the expected results
#   the number of tests that ran, but did not get the expected results
#   the number of tests that failed to run
#   the number of tests that were run but had no expected results to compare against

setConfiguration();
my $productDir = productDir();

chdirWebKit();

# Argument handling
my $testOnlySVGs = '';
my $pixelTests = '';
my $checkLeaks = '';
my $guardMalloc = '';
my $verbose = 0;
my $quiet = '';
my $singly = 0;
my $report10Slowest = 0;
my $launchSafari = 1;
my $testResultsDirectory = "/tmp/layout-test-results";

GetOptions('svg' => \$testOnlySVGs, 
    'pixel-tests|p' => \$pixelTests,
    'leaks|l' => \$checkLeaks,
    'guard-malloc|g' => \$guardMalloc,
    'verbose|v' => \$verbose,
    'quiet|q' => \$quiet,
    'singly|1' => \$singly,
    'slowest' => \$report10Slowest,
    'launch-safari!' => \$launchSafari,
    'results-directory|o=s' => \$testResultsDirectory);

my $dumpToolName = "DumpRenderTree";
my $result = system "WebKitTools/Scripts/build-dumprendertree", @ARGV;
exit $result if $result;
if ($testOnlySVGs) {
    $pixelTests = 1; # Pixel tests are always on for SVG.
}

my $tool = "$productDir/$dumpToolName";
my $imageDiffTool = "$productDir/ImageDiff";
die "can't find executable $dumpToolName (looked in $productDir)\n" if !-x $tool;
die "can't find executable $imageDiffTool (looked in $productDir)\n" if $pixelTests && !-x $imageDiffTool;

checkFrameworks();
my $haveSVGSupport = checkWebCoreSVGSupport($testOnlySVGs);

my $layoutTestsName = "LayoutTests";
if ($testOnlySVGs) {
    $layoutTestsName = "LayoutTests/svg";
}

my $workingDir = getcwd();
my $testDirectory = "$workingDir/$layoutTestsName";
my $testResults = "$testResultsDirectory/results.html";
print "Running tests from $testDirectory\n";

my @tests = ();

my $prunePart = "\\( -name resources \\! -prune \\)";
my $extensionPart = "-name '*.html' -or -name '*.xml' -or -name '*.xhtml'";
if ($testOnlySVGs) {
    $extensionPart = "-name '*.svg' -or -name '*.xml'";
} elsif ($haveSVGSupport) { 
    $extensionPart .= " -or -name '*.svg'";
} else {
    $prunePart .= " -or \\( -name svg \\! -prune \\)";
}
my $findArguments = "$prunePart -or $extensionPart";

my $foundTestName = 0;
for my $test (@ARGV) {
    next if $test =~ /^-/;
    $foundTestName = 1;
    $test =~ s/^$testDirectory\///;
    if ($test =~ /^\//) {
        print "can't run test outside $testDirectory\n";
    } elsif (-f "$testDirectory/$test") {
        if ($test !~ /\.(html|xml|xhtml|svg)$/) {
            print "test $test does not have a supported extension\n";
        } else {
            push @tests, $test;
        }
    } elsif (-d "$testDirectory/$test") {
        push @tests, sort pathcmp map { chomp; s-^$testDirectory/--; $_; } `find -Ls $testDirectory/$test $findArguments`;
    } else {
        print "test $test not found\n";
    }
}
if (!$foundTestName) {
    @tests = sort pathcmp map { chomp; s-^$testDirectory/--; $_; } `find -Ls $testDirectory $findArguments`;
}

die "no tests to run\n" if !@tests;

my %counts;
my %tests;
my %imagesPresent;
my %durations;
my $count = 0;
my $maxTestsPerLeaksRun = 1000; # more than 3000 and malloc logging will normally run out of memory
my $leaksOutputFileNumber = 1;
my $totalLeaks = 0;

my @toolArgs = ();

if ($pixelTests) {
    push @toolArgs, "--pixel-tests";
}

push @toolArgs, "-";

$| = 1;

my $imageDiffToolPID;
if ($pixelTests) {
    local %ENV;
    $ENV{MallocStackLogging} = 1 if $checkLeaks;
    $imageDiffToolPID = open2(\*DIFFIN, \*DIFFOUT, $imageDiffTool, "") or die "unable to open $imageDiffTool\n";
}

my $dumpToolPID;
my $toolOpen = 0;

my $atLineStart = 1;
my $lastDirectory = "";

printf("Testing %d test cases.\n", $#tests + 1);

sub openDumpRenderTreeIfNeeded()
{
    return if ($toolOpen);
    local %ENV;
    $ENV{DYLD_FRAMEWORK_PATH} = $productDir;
    $ENV{XML_CATALOG_FILES} = ""; # work around missing /etc/catalog <rdar://problem/4292995>
    $ENV{MallocStackLogging} = 1 if $checkLeaks;
    $ENV{DYLD_INSERT_LIBRARIES} = "/usr/lib/libgmalloc.dylib" if $guardMalloc;
    $dumpToolPID = open2(\*IN, \*OUT, $tool, @toolArgs) or die "Failed to start tool: $tool\n";
    $toolOpen = 1;
}

sub closeDumpRenderTree()
{
    close IN;
    close OUT;
    waitpid $dumpToolPID, 0;
    $toolOpen = 0;
}

sub fileNameWithNumber($$)
{
    my ($base, $number) = @_;
    return "$base$number" if ($number > 1);
    return $base;
}

for my $test (@tests) {
    next if $test eq 'results.html';

    openDumpRenderTreeIfNeeded();

    my $base = $test;
    $base =~ s/\.(html|xml|xhtml|svg)$//;
    
    if ($verbose || $singly) {
        print "running $test -> ";
        $atLineStart = 0;
    } elsif (!$quiet) {
        my $dir = $base;
        $dir =~ s|/[^/]+$||;
        if ($dir ne $lastDirectory) {
            print "\n" unless $atLineStart;
            print "$dir ";
            $lastDirectory = $dir;
        }
        print ".";
        $atLineStart = 0;
    }

    my $result;

    my $startTime = time if $report10Slowest;

    print OUT "$testDirectory/$test\n";

    my $actual = "";
    while (<IN>) {
        last if /#EOF/;
        $actual .= $_;
    }

    $durations{$test} = time - $startTime if $report10Slowest;

    my $expected;
    if (open EXPECTED, "<", "$testDirectory/$base-expected.txt") {
        $expected = "";
        while (<EXPECTED>) {
            $expected .= $_;
        }
        close EXPECTED;
    }

    if ($checkLeaks && $singly) {
        print "        $test -> ";
    }

    my $textDumpMatches = $expected && ($actual eq $expected);
    my $actualHash = "";
    my $expectedHash = "";
    my $hashMatches = "";
    my $actualPNG = "";
    my $actualPNGSize = 0;
    my $expectedPNG = "";
    my $expectedPNGSize = 0;
    my $diffPNG = "";
    my $diffPercentage = "";
    my $diffResult = "passed";
    
    if ($pixelTests) {
        while (<IN>) {
            last if /#EOF/;
            if (/ActualHash: ([a-f0-9]{32})/) {
                $actualHash = $1;
            } elsif (/BaselineHash: ([a-f0-9]{32})/) {
                $expectedHash = $1;
            } elsif (/Content-length: (\d+)\s*/) {
                $actualPNGSize = $1;
                read(IN, $actualPNG, $actualPNGSize);
            }
        }

        if ($hashMatches = ($expectedHash eq $actualHash)) {
            $diffResult = "passed";
        }

        if (!$hashMatches && -f "$testDirectory/$base-expected.png") {
            $expectedPNGSize = -s "$testDirectory/$base-expected.png";
            open EXPECTEDPNG, "$testDirectory/$base-expected.png";
            read(EXPECTEDPNG, $expectedPNG, $expectedPNGSize);

            print DIFFOUT "Content-length: $actualPNGSize\n";
            print DIFFOUT $actualPNG;

            print DIFFOUT "Content-length: $expectedPNGSize\n";
            print DIFFOUT $expectedPNG;

            while (<DIFFIN>) {
                last if /^error/ || /^diff:/;
                if (/Content-length: (\d+)\s*/) {
                    read(DIFFIN, $diffPNG, $1);
                }
            }

            if (/^diff: (.+)% (passed|failed)/) {
                $diffPercentage = $1;
                $diffResult = $2;
            }
        }
    }

    if ($pixelTests) {
        if ($actualPNGSize != 0 && ! -f "$testDirectory/$base-expected.png") {
            open EXPECTED, ">", "$testDirectory/$base-expected.png" or die "could not create $testDirectory/$base-expected.png\n";
            print EXPECTED $actualPNG;
            close EXPECTED;
        }

        # update the expected hash if the image diff said that there was no difference
        if ($actualHash ne "" && ! -f "$testDirectory/$base-expected.checksum") {
            open EXPECTED, ">", "$testDirectory/$base-expected.checksum" or die "could not create $testDirectory/$base-expected.checksum\n";
            print EXPECTED $actualHash;
            close EXPECTED;
        }
    }

    if (!defined $expected) {
        if ($verbose || $singly) {
            print "new test\n";
            $atLineStart = 1;
        }
        $result = "new";
        open EXPECTED, ">", "$testDirectory/$base-expected.txt" or die "could not create $testDirectory/$base-expected.txt\n";
        print EXPECTED $actual;
        close EXPECTED;
        unlink "$testResultsDirectory/$base-actual.txt";
        unlink "$testResultsDirectory/$base-diffs.txt";
    } elsif ($textDumpMatches && (!$pixelTests || ($pixelTests && $diffResult eq "passed"))) {
        if ($verbose || $singly) {
            print "succeeded\n";
            $atLineStart = 1;
        }
        $result = "match";
        unlink "$testResultsDirectory/$base-actual.txt";
        unlink "$testResultsDirectory/$base-diffs.txt";
    } elsif (!$textDumpMatches || ($pixelTests && $diffResult ne "passed")) {
        unless ($verbose || $singly) {
            print "\n" unless $atLineStart;
            print "$test -> ";
        }
        print "failed\n";
        $atLineStart = 1;

        $result = "mismatch";

        my $dir = "$testResultsDirectory/$base";
        $dir =~ s|/([^/]+)$|| or die "Failed to find test name from base\n";
        my $testName = $1;
        mkpath $dir;

        open ACTUAL, ">", "$testResultsDirectory/$base-actual.txt" or die;
        print ACTUAL $actual;
        close ACTUAL;

        system "diff -u \"$testDirectory/$base-expected.txt\" \"$testResultsDirectory/$base-actual.txt\" > \"$testResultsDirectory/$base-diffs.txt\"";

        if ($pixelTests && $diffPNG && $diffPNG ne "") {
            $imagesPresent{$base} = 1;

            open ACTUAL, ">", "$testResultsDirectory/$base-actual.png" or die;
            print ACTUAL $actualPNG;
            close ACTUAL;

            open DIFF, ">", "$testResultsDirectory/$base-diffs.png" or die;
            print DIFF $diffPNG;
            close DIFF;
            
            copy("$testDirectory/$base-expected.png", "$testResultsDirectory/$base-expected.png");

            open DIFFHTML, ">$testResultsDirectory/$base-diffs.html" or die;
            print DIFFHTML "<html>\n";
            print DIFFHTML "<head>\n";
            print DIFFHTML "<title>$base Image Compare</title>\n";
            print DIFFHTML "<script language=\"Javascript\" type=\"text/javascript\">\n";
            print DIFFHTML "var currentImage = 0;\n";
            print DIFFHTML "var imageNames = new Array(\"Actual\", \"Expected\");\n";
            print DIFFHTML "var imagePaths = new Array(\"$testName-actual.png\", \"$testName-expected.png\");\n";
            if (-f "$testDirectory/$base-w3c.png") {
                copy("$testDirectory/$base-w3c.png", "$testResultsDirectory/$base-w3c.png");
                print DIFFHTML "imageNames.push(\"W3C\");\n";
                print DIFFHTML "imagePaths.push(\"$testName-w3c.png\");\n";
            }
            print DIFFHTML "function animateImage() {\n";
            print DIFFHTML "    var image = document.getElementById(\"animatedImage\");\n";
            print DIFFHTML "    var imageText = document.getElementById(\"imageText\");\n";
            print DIFFHTML "    image.src = imagePaths[currentImage];\n";
            print DIFFHTML "    imageText.innerHTML = imageNames[currentImage] + \" Image\";\n";
            print DIFFHTML "    currentImage = (currentImage + 1) % imageNames.length;\n";
            print DIFFHTML "    setTimeout('animateImage()',2000);\n";
            print DIFFHTML "}\n";
            print DIFFHTML "</script>\n";
            print DIFFHTML "</head>\n";
            print DIFFHTML "<body onLoad=\"animateImage();\">\n";
            print DIFFHTML "<table>\n";
            if ($diffPercentage) {
                print DIFFHTML "<tr>\n";
                print DIFFHTML "<td>Difference between images: <a href=\"$testName-diffs.png\">$diffPercentage%</a></td>\n";
                print DIFFHTML "</tr>\n";
            }
            print DIFFHTML "<tr>\n";
            print DIFFHTML "<td id=\"imageText\" style=\"text-weight: bold;\">Actual Image</td>\n";
            print DIFFHTML "</tr>\n";
            print DIFFHTML "<tr>\n";
            print DIFFHTML "<td><img src=\"$testName-actual.png\" id=\"animatedImage\"></td>\n";
            print DIFFHTML "</tr>\n";
            print DIFFHTML "</table>\n";
            print DIFFHTML "</body>\n";
            print DIFFHTML "</html>\n";
        }
    } else {
        $result = "fail";
        print "\n" unless $atLineStart;
        print "$test -> crashed?\n";
        $atLineStart = 1;
        closeDumpRenderTree();
    }

    if ($checkLeaks && $toolOpen) {
        if ($singly) {
            $totalLeaks += countAndPrintLeaks($dumpToolName, $dumpToolPID, "$testResultsDirectory/$base-leaks.txt");
        } elsif ($count && (($count % $maxTestsPerLeaksRun) == 0)) {
            my $leaksFileName = fileNameWithNumber($dumpToolName, $leaksOutputFileNumber);
            my $leaksCount = countAndPrintLeaks($dumpToolName, $dumpToolPID, "$testResultsDirectory/$leaksFileName-leaks.txt");
            $leaksOutputFileNumber++ if ($leaksCount);
            $totalLeaks += $leaksCount;
            closeDumpRenderTree();
        }
    }

    if ($singly && $toolOpen) {
        closeDumpRenderTree();
    }

    $count += 1;
    $counts{$result} += 1;
    push @{$tests{$result}}, $test;
}

if ($checkLeaks && !$singly && $toolOpen) {
    my $leaksFileName = fileNameWithNumber($dumpToolName, $leaksOutputFileNumber);
    $totalLeaks += countAndPrintLeaks($dumpToolName, $dumpToolPID, "$testResultsDirectory/$leaksFileName-leaks.txt");
    $leaksOutputFileNumber++;
}

# FIXME: Do we really want to check the image-comparison tool for leaks every time?
if ($checkLeaks && $pixelTests) {
    $totalLeaks += countAndPrintLeaks("ImageDiff", $imageDiffToolPID, "$testResultsDirectory/ImageDiff-leaks.txt");
}

if ($totalLeaks) {
    print "\nWARNING: $totalLeaks total leaks found!\n";
    print "See above for individual leaks results.\n" if ($leaksOutputFileNumber > 2);
}

close IN;
close OUT;

my %text = (
    match => "succeeded",
    mismatch => "had incorrect layout",
    new => "were new",
    fail => "failed (tool did not execute successfully)",
);

if ($report10Slowest) {
    print "\n\nThe 10 slowest tests:\n\n";
    my $count = 0;
    for my $test (sort slowestcmp keys %durations) {
        printf "%0.2f secs: %s\n", $durations{$test}, $test;
        last if ++$count == 10;
    }
}

print "\n";

if ($counts{match} && $counts{match} == $count) {
    print "all $count test cases succeeded\n";
    unlink $testResults;
} else {
    for my $type ("match", "mismatch", "new", "fail") {
        my $c = $counts{$type};
        if ($c) {
            my $t = $text{$type};
            my $message;
            if ($c == 1) {
                $t =~ s/were/was/;
                $message = sprintf "1 test case (%d%%) %s\n", 1 * 100 / $count, $t;
            } else {
                $message = sprintf "%d test cases (%d%%) %s\n", $c, $c * 100 / $count, $t;
            }
            $message =~ s-\(0%\)-(<1%)-;
            print $message;
        }
    }
    
    mkpath $testResultsDirectory;

    open HTML, ">", $testResults or die;
    print HTML "<html>\n";
    print HTML "<head>\n";
    print HTML "<title>Layout Test Results</title>\n";
    print HTML "</head>\n";
    print HTML "<body>\n";

    if ($counts{mismatch}) {
        print HTML "<p>Tests where results did not match expected results:</p>\n";
        print HTML "<table>\n";
        for my $test (@{$tests{mismatch}}) {
            my $base = $test;
            $base =~ s/\.(html|xml|xhtml|svg)$//;
            copy("$testDirectory/$base-expected.txt", "$testResultsDirectory/$base-expected.txt");
            print HTML "<tr>\n";            
            print HTML "<td><a href=\"$testDirectory/$test\">$base</a></td>\n";
            if (-s "$testResultsDirectory/$base-diffs.txt") {
                print HTML "<td><a href=\"$base-expected.txt\">expected</a></td>\n";
                print HTML "<td><a href=\"$base-actual.txt\">actual</a></td>\n";
                print HTML "<td><a href=\"$base-diffs.txt\">diffs</a></td>\n";
            } else {
                print HTML "<td></td><td></td><td></td>\n";
            }
            if ($pixelTests) {
                if ($imagesPresent{$base}) {
                    print HTML "<td><a href=\"$base-expected.png\">expected image</a></td>\n";
                    print HTML "<td><a href=\"$base-diffs.html\">image diffs</a></td>\n";
                } else {
                    print HTML "<td></td><td></td>\n";
                }            
            }
            print HTML "</tr>\n";
        }
        print HTML "</table>\n";
    }

    if ($counts{fail}) {
        print HTML "<p>Tests that caused the DumpRenderTree tool to fail:</p>\n";
        print HTML "<table>\n";
        for my $test (@{$tests{fail}}) {
            my $base = $test;
            $base =~ s/\.(html|xml|xhtml|svg)$//;
            print HTML "<tr>\n";
            print HTML "<td><a href=\"$testDirectory/$test\">$base</a></td>\n";
            print HTML "</tr>\n";
        }
        print HTML "</table>\n";
    }

    if ($counts{new}) {
        print HTML "<p>Tests that had no expected results (probably new):</p>\n";
        print HTML "<table>\n";
        for my $test (@{$tests{new}}) {
            my $base = $test;
            $base =~ s/\.(html|xml|xhtml|svg)$//;
            print HTML "<tr>\n";
            print HTML "<td><a href=\"$testDirectory/$test\">$base</a></td>\n";
            print HTML "<td><a href=\"$testDirectory/$base-expected.txt\">results</a></td>\n";
            if ($pixelTests && -f "$testDirectory/$base-expected.png") {
                print HTML "<td><a href=\"$testDirectory/$base-expected.png\">image</a></td>\n";
            }
            print HTML "</tr>\n";
        }
        print HTML "</table>\n";
    }

    print HTML "</body>\n";
    print HTML "</html>\n";
    close HTML;
    
    if ($launchSafari) {
        system "WebKitTools/Scripts/run-safari", "-NSOpen", $testResults;
    }
    
    exit 1;
}

sub countAndPrintLeaks
{
    my ($toolName, $toolPID, $leaksFilePath) = @_;

    print "\n" unless $atLineStart;
    $atLineStart = 1;

    # We are excluding the following reported leaks so they don't get in our way when looking for WebKit leaks:

    my @exclude = (
        "pthread_create", # false positive leak of 'THRD', Radar 3387783
        "_CFPreferencesDomainDeepCopyDictionary", # leak apparently in CFPreferences, Radar 4220786
        "+[NSLanguage initialize]", # leak apparently in NSLanguage, Radar 3986177
        "FOGetCoveredUnicodeChars", # leak apparently in ATS, Radar 3943604
        "PCFragPrepareClosureFromFile", # leak in Code Fragment Manager, Radar 3426998
        "Flash_EnforceLocalSecurity" # leaks in flash plugin code, Radar 4449747
    );

    # Note that this exclusion doesn't quite work right; sometimes a leak of 'THRD' with no stack trace will
    # still appear in the leaks output.

    my $excludes = "-exclude '" . (join "' -exclude '", @exclude) . "'";

    print " ? checking for leaks in $toolName\n";
    my $leaksOutput = `leaks $excludes $toolPID`;
    my ($count, $bytes) = $leaksOutput =~ /Process $toolPID: (\d+) leaks? for (\d+) total/;
    my ($excluded) = $leaksOutput =~ /(\d+) leaks? excluded/;

    if ($count == 0 || ($excluded && $count <= $excluded)) {
        print " - no leaks found\n";
        unlink $leaksFilePath;
        return 0;
    } else {
        my $dir = $leaksFilePath;
        $dir =~ s|/[^/]+$|| or die;
        mkpath $dir;

        print " + $count leaks ($bytes bytes) were found, details in $leaksFilePath\n";
        open LEAKS, ">", $leaksFilePath or die;
        print LEAKS $leaksOutput;
        close LEAKS;
    }
    return $count;
}

# Break up a path into the directory (with slash) and base name.
sub splitpath($)
{
    my ($path) = @_;

    return ($1, $2) if $path =~ m|^(.*/)([^/]+)$|;
    return ("", $path);
}

# Sort first by directory, then by file, so all paths in one directory are grouped
# rather than being interspersed with items from subdirectories.
# Use numericcmp to sort directory and filenames to make order logical.
sub pathcmp($$)
{
    my ($patha, $pathb) = @_;

    my ($dira, $namea) = splitpath($patha);
    my ($dirb, $nameb) = splitpath($pathb);

    return numericcmp($dira, $dirb) if $dira ne $dirb;
    return numericcmp($namea, $nameb);
}

# Sort numeric parts of strings as numbers, other parts as strings.
# Makes 1.33 come after 1.3, which is cool.
sub numericcmp($$)
{
    my ($aa, $bb) = @_;

    my @a = split /(\d+)/, $aa;
    my @b = split /(\d+)/, $bb;

    # Compare one chunk at a time.
    # Each chunk is either all numeric digits, or all not numeric digits.
    while (@a && @b) {
        my $a = shift @a;
        my $b = shift @b;
        
        # Use numeric comparison if chunks are non-equal numbers.
        return $a <=> $b if $a =~ /^\d/ && $b =~ /^\d/ && $a != $b;

        # Use string comparison if chunks are any other kind of non-equal string.
        return $a cmp $b if $a ne $b;
    }
    
    # One of the two is now empty; compare lengths for result in this case.
    return @a <=> @b;
}

# Sort slowest tests first.
sub slowestcmp($$)
{
    my ($testa, $testb) = @_;

    my $dura = $durations{$testa};
    my $durb = $durations{$testb};
    return $durb <=> $dura if $dura != $durb;
    return pathcmp($testa, $testb);
}
