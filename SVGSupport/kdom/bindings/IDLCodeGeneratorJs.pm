#
# KDOM IDL parser
#
# Copyright (c) 2005 Nikolas Zimmermann <wildfox@kde.org>
#
package IDLCodeGeneratorJs;

my $useModule = "";
my $useModuleNS = "";
my $useOutputDir = "";

my $codeGenerator;

my $IMPL;
my $HEADER;

my @implContent; # .cpp file content
my @headerContent; # .h file content

my @neededIncludes; # Used to build up include list

# Default .h template
my $headerTemplate = << "EOF";
/*
    This file is part of the KDE project.
    This file has been generated by kdomidl.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/
EOF

# Default constructor
sub new
{
	my $object = shift;
	my $reference = { };

	$codeGenerator = shift;
	$useOutputDir = shift;

	bless($reference, $object);
	return $reference;
}

sub finish
{
	my $object = shift;

	# Commit changes!
	$object->WriteData();
}

# Params: 'idlDocument' struct
sub GenerateModule
{
	my $object = shift;
	my $dataNode = shift;

	# Create module <-> namespace map...
	$codeGenerator->CreateModuleNamespaceHash();

	$useModule = $dataNode->module;

	my %hash = %{$codeGenerator->ModuleNamespaceHash()};
	$useModuleNS = $hash{$useModule};
}

# Params: 'domClass' struct
sub GenerateInterface
{
	my $object = shift;
	my $dataNode = shift;

	$object->WriteData();

	# Only process parent IDLs if we _really_ need it.
	my @parents = @{$dataNode->parents};
	my $parentsMax = @{$dataNode->parents};

	my $topBaseClass = "";

	# Exception: For the DOM 'Node' is our topmost baseclass, not EventTarget.
	if(($parentsMax > 0) and ($parents[0] ne "events::EventTarget")) { # Determine topmost baseclass, if needed
		my %firstParentType = $codeGenerator->ExtractNamespace($parents[0], 1, $useModuleNS);

		$topBaseClass = $codeGenerator->FindTopBaseClass($firstParentType{'type'});
		my %baseClassType = $codeGenerator->ExtractNamespace($topBaseClass, 1, $useModuleNS);

		if($baseClassType{'type'} ne "") {
			if(($baseClassType{'namespace'} ne "") and ($baseClassType{'namespace'} ne $useModuleNS)) {
				$topBaseClass = $baseClassType{'namespace'} . "::" . $baseClassType{'type'};
			} else {
				$topBaseClass = $baseClassType{'type'};
			}

			print "  |  |----> Determined \"$topBaseClass\" as topmost baseclass!\n  |  |\n";
		}
	}

	# Start actual generation..
	print "  |  |>  Generating header...\n";
	$object->GenerateHeader($dataNode, $topBaseClass);

	print "  |  |>  Generating implementation...\n";
	$object->GenerateImplementation($dataNode, $topBaseClass);

	print " |-\n |\n";
  
	my %type = $codeGenerator->ExtractNamespace($dataNode->name, 1, $useModuleNS);

	# Open files for writing...
	my $implFileName = $useOutputDir . "/$useModule/" . $type{'type'} . "Wrapper.cpp";
	my $headerFileName = $useOutputDir . "/$useModule/" . $type{'type'} . "Wrapper.h";

	open($IMPL, ">$implFileName") || die "Coudln't open file $implFileName";
	open($HEADER, ">$headerFileName") || die "Coudln't open file $headerFileName";
}

sub GenerateHeader
{
	my $object = shift;

	my $dataNode = shift;
	my $topBaseClass = shift;

	my $parentsMax = @{$dataNode->parents};
	my %extractedType = $codeGenerator->ExtractNamespace($dataNode->name, 1, $useModuleNS);
	$extractedType{'type'} .= "Wrapper"; # Postfix the classname...

	if(!defined($HEADER)) {
		# - Add default header template
		@headerContent = split("\r", $headerTemplate);

		# - Add header protection
		my $printNS = $useModuleNS; $printNS =~ s/\:\:/\_/g;
		push(@headerContent, "\n#ifndef $printNS\_" . $extractedType{'type'} . "_JS_H\n");
		push(@headerContent, "#define $printNS\_" . $extractedType{'type'} . "_JS_H\n");

		# - Add default includes & parent header includes
		push(@headerContent, "\n#include <kdebug.h>\n");
		push(@headerContent, "\n#include <kjs/object.h>\n\n");

		foreach(@{$dataNode->parents}) {
			my $includeFile = $codeGenerator->GenerateInclude($_);
			push(@headerContent, "#include \"${includeFile}Wrapper.h\"\n");
		}

		push(@headerContent, "\n") if($parentsMax > 0);

		# - Add namespace selector(s)
		my @namespaces = @{$codeGenerator->SplitNamespaces($useModuleNS)};

		my $collectedNS = "";
		foreach(@namespaces) {
			$collectedNS .= $_ . "::";

			my $showNS = substr($collectedNS, 0, length($collectedNS) - 2);
			push(@headerContent, "namespace $_\n{\n");
		}
	}

	# - Determines wheter we have any readwrite props...
	my $hasReadWriteProperties = 0;
	foreach(@{$dataNode->attributes}) {
		if($_->type !~ /^readonly\ attribute$/) {
			$hasReadWriteProperties = 1;
		}
	}

	my $implClass = $extractedType{'type'};
	$implClass =~ s/Wrapper$/Impl/;

	# - Add class definition (with correct inheritance order)
	my $parentString = "\tclass $implClass;\n\tclass " . $extractedType{'type'};
	$parentString .= " : " if($parentsMax ne 0);

	my $h = 0;
	foreach(@{$dataNode->parents}) {
		my %ret = $codeGenerator->ExtractNamespace($_, 1, $useModuleNS);

		if(($ret{'namespace'} ne "") and ($ret{'namespace'} ne $useModuleNS)) {
			$parentString .= "public " . $ret{'namespace'} . "::" . $ret{'type'} . "Wrapper";
		} else {
			$parentString .= "public " . $ret{'type'} . "Wrapper";
		}

		$parentString .= ",\n\t\t\t\t" if($h++ < $parentsMax - 1);
	}

	$parentString .= "\n\t{\n\tpublic:\n";
	push(@headerContent, $parentString);

	# - Add default constructor & destructor
	push(@headerContent, "\t\t" . $extractedType{'type'} . "($implClass *impl);\n");
	push(@headerContent, "\t\tvirtual ~" . $extractedType{'type'} . "();\n\n");

	# - Add standard ecma functions
	push(@headerContent, "\t\tvirtual const KJS::ClassInfo *classInfo() const;\n");
	push(@headerContent, "\t\tvirtual KJS::UString toString(KJS::ExecState *exec) const;\n\n");

	push(@headerContent, "\t\tvirtual bool hasProperty(KJS::ExecState *exec, " .
						 "const KJS::Identifier &propertyName) const;\n\n");

	push(@headerContent, "\t\tvirtual KJS::ValueImp *get(KJS::ExecState *exec, " .
						 "const KJS::Identifier &propertyName, const KJS::ObjectImp *bridge) const;\n");
	
	push(@headerContent, "\t\tKJS::ValueImp *getInParents(KJS::ExecState *exec, " .
						 "const KJS::Identifier &propertyName, const KJS::ObjectImp *bridge) const;\n\n");

	if($hasReadWriteProperties eq 1) {
		push(@headerContent, "\t\tvirtual bool put(KJS::ExecState *exec, " .
							 "const KJS::Identifier &propertyName, KJS::ValueImp *value, int attr);\n");

		push(@headerContent, "\t\tbool putInParents(KJS::ExecState *exec, " .
							 "const KJS::Identifier &propertyName, KJS::ValueImp *value, int attr);\n\n");
	}

	push(@headerContent, "\t\tKJS::ObjectImp *prototype(KJS::ExecState *exec) const;\n\n");
	push(@headerContent, "\t\tKJS::ObjectImp *bridge(KJS::ExecState *exec) const;\n");

	my $cacheVirtual = ""; # 'cache' must be virtual for baseclasses...
	$cacheVirtual = "virtual " if($parentsMax eq 0);

	push(@headerContent, "\t\t${cacheVirtual}KJS::ValueImp *cache(KJS::ExecState *exec) const;\n\n");

	push(@headerContent, "\t\tstatic const KJS::ClassInfo s_classInfo;\n");
	push(@headerContent, "\t\tstatic const struct KJS::HashTable s_hashTable;\n\n");

	# - Add all attributes
	my $attributesMax = @{$dataNode->attributes};
	my $functionsMax = @{$dataNode->functions};

	push(@headerContent, "\t\tenum\n\t\t{\n\t\t\t// Attributes\n\t\t\t");

	if($attributesMax eq 0) {
		push(@headerContent, "Dummy");
		push(@headerContent, ", ") if($functionsMax ne 0);
	}

	my $i = -1;
	foreach(@{$dataNode->attributes}) {
		my $attribute = $_;

		$i++;
		if((($i % 2) eq 0) and ($i ne 0)) {
			push(@headerContent, "\n\t\t\t");
		}

		my $value = ucfirst($attribute->signature->name);
		$value .= ", " if(($i < $attributesMax - 1));
		$value .= ", " if(($i eq $attributesMax - 1) and ($functionsMax ne 0));
		push(@headerContent, $value);
	}

	# - Add all functions
	if($functionsMax > 0) {
		push(@headerContent, "\n\n\t\t\t// Functions\n\t\t\t");
	}

	$i = -1;
	foreach(@{$dataNode->functions}) {
		my $function = $_;

		$i++;
		if((($i % 2) eq 0) and ($i ne 0)) {
			push(@headerContent, "\n\t\t\t");
		}

		my $value = ucfirst($function->signature->name);
		$value .= ", " if($i < $functionsMax - 1);
		push(@headerContent, $value);
	}

	push(@headerContent, "\n\t\t};\n");

	# - Add getValueProperty function
	push(@headerContent, "\n\t\tKJS::ValueImp *getValueProperty(KJS::ExecState *exec, int token) const;\n");

	# - Add putValueProperty function, if we have any writable attributes...
	if($hasReadWriteProperties eq 1) {
		push(@headerContent, "\t\tvoid putValueProperty(KJS::ExecState *exec, int token, " .
							 "KJS::ValueImp *value, int attr);\n");
	}

	# - Add 'private' section to store impl ptr...
	push(@headerContent, "\n\tprivate:\n\t\t$implClass *m_impl;\n\t};");

	# End header...
	my @namespaces = @{$codeGenerator->SplitNamespaces($useModuleNS)};
	my $namespacesMax = @namespaces;

	my $addedTo = 0;
	foreach(@namespaces) {
		if($addedTo eq 0) {
			my $toId = "to" . ucfirst($extractedType{'type'});
			$toId =~ s/Wrapper$//;

			$addedTo = 1;
			push(@headerContent, "\n\n\t$implClass *$toId(KJS::ExecState *exec, " .
								 "const KJS::ObjectImp *bridge);")
		}

		push(@headerContent, "\n};\n");
	}

	push(@headerContent, "\n#endif\n");
}

sub GenerateImplementation
{
	my $object = shift;

	my $dataNode = shift;
	my $topBaseClass = shift;

	my $parentsMax = @{$dataNode->parents};

	my %extractedType = $codeGenerator->ExtractNamespace($dataNode->name, 1, $useModuleNS);
	$extractedType{'type'} .= "Wrapper"; # Postfix the classname...

	my $implClass = $extractedType{'type'};
	$implClass =~ s/Wrapper$/Impl/;

	if(!defined($IMPL)) {
		# - Add default header template
		@implContent = split("\r", $headerTemplate);

		# - Add absolutely needed includes
		push(@implContent, "\n#include \"" . $extractedType{'type'} . ".h\"");
		push(@implContent, "\n#include \"$implClass.h\"\n");

		push(@implContent, "\n#include <kdom/ecma/Ecma.h>");
		push(@implContent, "\n#include <kdom/ecma/DOMBridge.h>");
		push(@implContent, "\n#include <kdom/ecma/DOMLookup.h>\n");
		push(@implContent, "\n#include \"DOMExceptionImpl.h\"\n\n");

		# - Add placeholder to be replaced with needed includes, later.
		push(@implContent, "#FIXUP_INCLUDES#");

		# - Add namespace selector(s)
		my @namespaces = @{$codeGenerator->SplitNamespaces($useModuleNS)};

		my $collectedNS = "";
		foreach(@namespaces) {
			$collectedNS .= $_ . "::";

			my $showNS = substr($collectedNS, 0, length($collectedNS) - 2);
			push(@implContent, "using namespace $showNS;\n");
		}

		# - Initialize static ClassInfo object
		my $classIdentifier = $extractedType{'type'};
		$classIdentifier =~ s/Wrapper$//;

		push(@implContent, "\nconst KJS::ClassInfo " . $extractedType{'type'} .
						   "::s_classInfo = { \"$classIdentifier\", 0, &" .
						   $extractedType{'type'} . "::s_hashTable, 0 };\n");
	}

	# - Determines wheter we have any readwrite props...
	my $hasReadWriteProperties = 0;
	foreach(@{$dataNode->attributes}) {
		if($_->type !~ /^readonly\ attribute$/) {
			$hasReadWriteProperties = 1;
		}
	}

	# - Add default ctor / impl ctor / copy ctor & destructor
	my $ctorString = " : m_impl(impl)";

	my $h = 0;
	foreach(@{$dataNode->parents}) {
		$h++;

		my %ret = $codeGenerator->ExtractNamespace($_, 1, $useModuleNS);
		my $type = $ret{'type'};

		$ctorString = " : " if($h eq 1);
		$ctorString .= "${type}Wrapper(impl)";
		$ctorString .= ", " if($h < $parentsMax);
		$ctorString .= ", m_impl(impl)" if($h eq $parentsMax);
	}
	
	push(@implContent, "\n" . $extractedType{'type'} . "::" . $extractedType{'type'} .
					   "($implClass *impl)$ctorString\n{\n}\n\n");

	push(@implContent, $extractedType{'type'} . "::~" . $extractedType{'type'} . "()\n{\n}\n\n");

	# - Add all attributes in a hashtable definition
	my $attributesMax = @{$dataNode->attributes};
	my $hashSize = $attributesMax;
	my $hashName = $dataNode->name . "Wrapper::s_hashTable";

	my @hashKeys = ();			# ie. 'insertBefore'
	my @hashValues = ();		# ie. 'NodeWrapper::InsertBefore'
	my @hashSpecials = ();		# ie. 'KJS::DontDelete|KJS::Function'
	my @hashParameters = ();	# ie. '2'

	foreach(@{$dataNode->attributes}) {
		my $attribute = $_;

		my $name = $attribute->signature->name;
		push(@hashKeys, $name);
		
		my $value = $extractedType{'type'} . "::" . ucfirst($name);
		push(@hashValues, $value);

		my $special = "KJS::DontDelete";
		$special .= "|KJS::ReadOnly" if($attribute->type =~ /readonly/);
		push(@hashSpecials, $special);

		my $parameters = "0";
		push(@hashParameters, $parameters);
	}

	if($hashSize eq 0) { # Generate dummy hashtable
		my $name = "dummy";
		push(@hashKeys, $name);

		my $value = $extractedType{'type'} . "::" . ucfirst($name);
		push(@hashValues, $value);

		my $special = "KJS::DontDelete";
		push(@hashSpecials, $special);

		my $parameters = "0";
		push(@hashParameters, $parameters);

		$hashSize++;
	}

	$object->GenerateHashTable($hashName, $hashSize,
							   \@hashKeys, \@hashValues,
							   \@hashSpecials, \@hashParameters);

	# - Add all functions in a hashtable definition, if we have any.
	my $functionsMax = @{$dataNode->functions};
	if($functionsMax ne 0) {
		$hashSize = $functionsMax;
		$hashName = $dataNode->name . "WrapperProto::s_hashTable";

		@hashKeys = ();
		@hashValues = ();
		@hashSpecials = ();
		@hashParameters = ();

		foreach(@{$dataNode->functions}) {
			my $function = $_;

			my $name = $function->signature->name;
			push(@hashKeys, $name);
		
			my $value = $extractedType{'type'} . "::" . ucfirst($name);
			push(@hashValues, $value);

			my $special = "KJS::DontDelete|KJS::Function";
			push(@hashSpecials, $special);

			my $parameters = @{$function->parameters};
			push(@hashParameters, $parameters);
		}

		$object->GenerateHashTable($hashName, $hashSize,
								   \@hashKeys, \@hashValues,
								   \@hashSpecials, \@hashParameters);
	}

	# - Add 'classInfo' function (always needed!)
	push(@implContent, "/* Standard ecma functions */\n" .
					   "const KJS::ClassInfo *" . $extractedType{'type'} . "::" .
					   "classInfo() const\n{\n\treturn &s_classInfo;\n}\n\n");

	# - Add 'toString' function (always needed!)
	push(@implContent, "KJS::UString " . $extractedType{'type'} . "::" .
					   "toString(KJS::ExecState *) const\n{\n\treturn " .
					   "KJS::UString(\"[object \" + QString::fromLatin1(" .
					   $extractedType{'type'} . "::s_classInfo.className) " .
					   "+ \"]\");\n}\n\n");

	# - Add 'hasProperty' function (always needed!)
	push(@implContent, "bool " . $extractedType{'type'} . "::hasProperty(" .
					   "KJS::ExecState *exec, const KJS::Identifier &propertyName) const\n{\n" .
					   "\tconst KJS::HashEntry *e = KJS::Lookup::findEntry(&" . $extractedType{'type'} .
					   "::s_hashTable, propertyName);\n\tif(e)\n\t\treturn true;\n");

	if(($parentsMax eq 0) and ($functionsMax eq 0)) {
		push(@implContent, "\n\tQ_UNUSED(exec);\n");
	} else {
		if($functionsMax ne 0) {
			my $classIdentifier = $extractedType{'type'};
			$classIdentifier =~ s/Wrapper$//;

			push(@implContent, "\n\tKJS::ObjectImp *proto = ${classIdentifier}WrapperProto::self(" .
							   "exec);\n\tif(proto->hasProperty(exec, propertyName))\n" .
							   "\t\treturn true;\n");
		}

		if($parentsMax ne 0) {
			foreach(@{$dataNode->parents}) {
				my %ret = $codeGenerator->ExtractNamespace($_, 1, $useModuleNS);
				my $parentIdentifier = "";

				if(($ret{'namespace'} ne "") and ($ret{'namespace'} ne $useModuleNS)) {
					$parentIdentifier = $ret{'namespace'} . "::" . $ret{'type'} . "Wrapper";
				} else {
					$parentIdentifier = $ret{'type'} . "Wrapper";
				}

    			push(@implContent, "\n\tif(${parentIdentifier}::hasProperty(exec, " .
								   "propertyName))\n\t\treturn true;\n");
			}

			push(@implContent, "\n");
		}
	}

	push(@implContent, "\treturn false;\n}\n\n");

	# - Add 'get' function (always needed!)
	push(@implContent, "KJS::ValueImp *" . $extractedType{'type'} . "::get(KJS::ExecState *exec, " .
					   "const KJS::Identifier &propertyName, const KJS::ObjectImp *bridge) const\n");

	if($functionsMax eq 0) {
		push(@implContent, "{\n\treturn lookupGetValue<" . $extractedType{'type'} . ">(exec, " .
						   "propertyName, &s_hashTable, this, bridge);\n}\n\n");
	} else {
		push(@implContent, "{\n\treturn lookupGet<" . $extractedType{'type'} . "ProtoFunc, " .
						   $extractedType{'type'} . ">(exec, propertyName, &s_hashTable, this, bridge);\n}\n\n");
	}

	# - Add 'getInParents' function (always needed!)
	push(@implContent, "KJS::ValueImp *" . $extractedType{'type'} . "::getInParents(KJS::ExecState *exec, " .
					   "const KJS::Identifier &propertyName, const KJS::ObjectImp *bridge) const\n{\n");

	my $paramsUsed = 0;

	if($functionsMax ne 0) {
		push(@implContent, "\tKJS::ObjectImp *proto = " . $extractedType{'type'} . "Proto::self(exec);\n" .
						   "\tif(proto->hasProperty(exec, propertyName))\n\t\t" .
						   "return proto->get(exec, propertyName);\n\n");

		$paramsUsed = 1;
	}

	if($parentsMax ne 0) {
		foreach(@{$dataNode->parents}) {
			my %ret = $codeGenerator->ExtractNamespace($_, 1, $useModuleNS);
			my $parentIdentifier = "";

			if(($ret{'namespace'} ne "") and ($ret{'namespace'} ne $useModuleNS)) {
				$parentIdentifier = $ret{'namespace'} . "::" . $ret{'type'} . "Wrapper";
			} else {
				$parentIdentifier = $ret{'type'} . "Wrapper";
			}

			push(@implContent, "\tif(${parentIdentifier}::hasProperty(exec, propertyName))\n\t\t" .
							   "return ${parentIdentifier}::get(exec, propertyName, bridge);\n\n");
		}

		$paramsUsed = 2;
	}

	if($paramsUsed eq 0) {
		push(@implContent, "\tQ_UNUSED(exec); Q_UNUSED(propertyName); Q_UNUSED(bridge);\n");
	} elsif($paramsUsed eq 1) {
		push(@implContent, "\tQ_UNUSED(bridge);\n");
	}

	push(@implContent, "\treturn KJS::Undefined();\n}\n");

	# - Add 'put'/'putInParents' functions, if we have writeable properties...
	if($hasReadWriteProperties eq 1) {
		push(@implContent, "\nbool " . $extractedType{'type'} . "::put(KJS::ExecState *exec, " .
						   "const KJS::Identifier &propertyName, KJS::ValueImp *value, int attr)\n" .
						   "{\n\treturn lookupPut<" . $extractedType{'type'} .">(exec, propertyName, " .
						   "value, attr, &s_hashTable, this);\n}\n\n");

		push(@implContent, "bool " . $extractedType{'type'} . "::putInParents(KJS::ExecState *exec, " .
						   "const KJS::Identifier &propertyName, KJS::ValueImp *value, int attr)\n{");

		my $generatedAnything = 0;

		foreach(@{$dataNode->parents}) {
			my %ret = $codeGenerator->ExtractNamespace($_, 1, $useModuleNS);

			# Skip classes which don't define any writable attributes...
			if($codeGenerator->ClassHasWriteableAttributes($ret{'type'}) eq 0) {
				next;
			}

			my $parentIdentifier = "";

			if(($ret{'namespace'} ne "") and ($ret{'namespace'} ne $useModuleNS)) {
				$parentIdentifier = $ret{'namespace'} . "::" . $ret{'type'} . "Wrapper";
			} else {
				$parentIdentifier = $ret{'type'} . "Wrapper";
			}

			push(@implContent, "\n\tif(${parentIdentifier}::hasProperty(exec, " .
							   "propertyName))\n\t{\n\t\t${parentIdentifier}::put(exec, " .
							   "propertyName, value, attr);\n\t\treturn true;\n\t}\n");

			$generatedAnything = 1;
		}

		if(($parentsMax eq 0) or ($generatedAnything eq 0)) {
			push(@implContent, "\n\tQ_UNUSED(exec);\n\tQ_UNUSED(propertyName);\n" .
							   "\tQ_UNUSED(value);\n\tQ_UNUSED(attr);\n");
		}

		push(@implContent, "\n") if($generatedAnything eq 1);
		push(@implContent, "\treturn false;\n}\n");
	}

	# - Add 'cast' function for JSWrapperProtoFunc classes, if we have functions...
	my $toId = "to" . ucfirst($extractedType{'type'});
	$toId =~ s/Wrapper$//;

	if($functionsMax ne 0) {
    	push(@implContent, "\n$implClass *" . $extractedType{'type'} . "ProtoFunc::cast(" .
						   "KJS::ExecState *exec, const KJS::ObjectImp *bridge) const\n{\n\t" .
						   "return $useModuleNS" . "::$toId(exec, bridge);\n}\n");
	}

	# - Add 'prototype' function (always needed!)
	push(@implContent, "\nKJS::ObjectImp *" . $extractedType{'type'} . "::prototype(KJS::ExecState *exec) const");

	if($functionsMax eq 0) {
		push(@implContent, "\n{\n\tif(exec)\n\t\treturn exec->interpreter()->builtinObjectPrototype();");
	} else {
		push(@implContent, "\n{\n\tif(exec)\n\t\treturn " . $extractedType{'type'} . "Proto::self(exec);");
	}
			
	push(@implContent, "\n\n\treturn NULL;\n}\n");

	# - Add 'bridge' function (always needed!)
	my $useBridge = "DOMBridge";
	$useBridge = "DOMRWBridge" if($hasReadWriteProperties eq 1);

	push(@implContent, "\nKJS::ObjectImp *" . $extractedType{'type'} . "::bridge(" .
					   "KJS::ExecState *exec) const\n{\n\treturn new " .
					   "$useBridge<" . $extractedType{'type'} . ", $implClass>(" .
					   "exec, m_impl);\n}\n");

	# - Add 'cache' function (always needed!)
	push(@implContent, "\nKJS::ValueImp *" . $extractedType{'type'} . "::cache(KJS::ExecState *exec) const\n{\n\t" .
					   "return cacheDOMObject<" . $extractedType{'type'} . ", $implClass>(exec, this);\n}\n");

	# - Add 'to...' function (always needed!)
	# TODO: implement stub!
	push(@implContent, "\n$implClass *" . $useModuleNS . "::$toId(KJS::ExecState *" .
					   "exec, const KJS::ObjectImp *bridge)\n{\n\t");

	push(@implContent, "\n\treturn 0;\n}\n");

	# - Add 'getValueProperty' function (always needed!)
	# TODO: catch exceptions!
	push(@implContent, "\nKJS::ValueImp *" . $extractedType{'type'} . "::getValueProperty(KJS::ExecState *exec" .
					   ", int token) const\n{\n\tswitch(token)\n\t{");

	my $execUsed = 0;
	foreach(@{$dataNode->attributes}) {
		my $attribute = $_;

		my %paramType = $codeGenerator->ExtractNamespace($attribute->signature->type, 0, $useModuleNS);

		my $name = $attribute->signature->name;
		my $value = $extractedType{'type'} . "::" . ucfirst($name);

		my $returnValue = $object->TypeToEcma($name, \%paramType, 0);
		$execUsed = 1 if($returnValue =~ /exec/);
		push(@implContent, "\n\t\tcase $value:\n\t\t\t$returnValue");
	}

	push(@implContent, "\n\t\tdefault:\n\t\t\tkdWarning() << \"Unhandled token in" .
					   " \" << k_funcinfo << \" : \" << token << endl;\n\t}\n");

	push(@implContent, "\n\tQ_UNUSED(exec);") if($execUsed eq 0);
	push(@implContent, "\n\treturn KJS::Undefined();\n}\n");

	# - Add 'putValueProperty' function, if we have writeable attributes...
	# TODO: catch exceptions!
	if($hasReadWriteProperties eq 1) {
		push(@implContent, "\nvoid " . $extractedType{'type'} . "::putValueProperty(KJS::ExecState *exec" .
						   ", int token, KJS::ValueImp *value, int)\n{\n\tswitch(token)\n\t{");

		foreach(@{$dataNode->attributes}) {
			my $attribute = $_;

			if($attribute->type !~ /^readonly\ attribute$/) {
				my %paramType = $codeGenerator->ExtractNamespace($attribute->signature->type, 0, $useModuleNS);

				my $name = $attribute->signature->name;
				my $value = $extractedType{'type'} . "::" . ucfirst($name);

				my $returnValue = $object->TypeToEcma("set" . ucfirst($name), \%paramType, 1);
				push(@implContent, "\n\t\tcase $value:\n\t\t{\n\t\t\t$returnValue\n\t\t}");
			}
		}

		push(@implContent, "\n\t\tdefault:\n\t\t\tkdWarning() << \"Unhandled token in" .
						   " \" << k_funcinfo << \" : \" << token << endl;\n\t}\n}\n");
	}

	# - Add 'call' function, if we have have functions...
	# TODO: implement the stub! (KDOM_CHECK_THIS, KDOM_ENTER/LEAVE_SAFE, switch(id) content)
	if($functionsMax ne 0) {
		push(@implContent, "\nKJS::ValueImp *" . $extractedType{'type'} . "ProtoFunc::callAsFunction(KJS::ExecState * /* exec */" .
						   ", KJS::ObjectImp * /* thisObj */, const KJS::List & /* args */)\n{\n\t" .
						   "switch(id)\n\t{\n\t\t");

		push(@implContent, "default:\n\t\t\tkdWarning() << \"Unhandled function id in \" " .
						   "<< k_funcinfo << \" : \" << id << endl;\n\t\t\tbreak;\n\t}\n\n\t" .
						   "return KJS::Undefined();\n}\n");
	}

	# ... and apply fixups!
	my $tempData = join("@", @implContent);

	my $fixupString = "";
	foreach(@neededIncludes) {
		$fixupString .= "#include \"${_}.h\"\n";
	}

	$fixupString .= "\n" if($fixupString ne "");

	$tempData =~ s/#FIXUP_INCLUDES#/$fixupString/;
	@implContent = split("@", $tempData);
}

# Internal Helper
sub GenerateHashTable
{
	my $object = shift;

	my $name = shift;
	my $size = shift;
	my $keys = shift;
	my $values = shift;
	my $specials = shift;
	my $parameters = shift;

	# Helpers
	my @table = ();
	my @links = ();

	my $maxDepth = 0;
	my $collisions = 0;
	my $savedSize = $size;

	# Collect hashtable information...
	my $i = 0;
	foreach(@{$keys}) {
		my $depth = 0;
		my $h = $object->GenerateHashValue($_) % $savedSize;

		while(defined($table[$h])) {
			if(defined($links[$h])) {
				$h = $links[$h];
				$depth++;
			} else {
				$collisions++;
				$links[$h] = $size;
				$h = $size;
				$size++;
			}
		}
	
		$table[$h] = $i;

		$i++;
		$maxDepth = $depth if($depth > $maxDepth);
	}

	# Ensure table is big enough (in case of undef entries at the end)
	if($#table + 1 < $size) {
		$#table = $size - 1;
	}

	# Start outputing the hashtables...
	my $nameEntries = "${name}Entries";
	$nameEntries =~ s/:/_/g;

#	my $nameStringTable = "${name}Strings";
#	$nameStringTable =~ y/:/_/;

	# first, build the string table
	my %soffset = ();
	if($name =~ /Proto\:\:/) { # Define prototype first...
		my $type = $name; $type =~ s/Proto\:\:.*//;
		my $implClass = $type; $implClass =~ s/Wrapper$/Impl/;

		push(@implContent, "/* Hash table for prototype */");

		my @namespaces = @{$codeGenerator->SplitNamespaces($useModuleNS)};

		foreach(@namespaces) {
			push(@implContent, "\nnamespace $_\n{\n");
		}

		push(@implContent, "\tECMA_DEFINE_PROTOTYPE(${type}Proto)\n");
		push(@implContent, "\tECMA_IMPLEMENT_PROTOFUNC(${type}ProtoFunc, $type, $implClass)\n");
		push(@implContent, "\tECMA_IMPLEMENT_PROTOTYPE(\"$type\", ${type}Proto, ${type}ProtoFunc)");

		foreach(@namespaces) {
			push(@implContent, "\n};\n");
		}

		push(@implContent, "\n");
	} else {
		push(@implContent, "/* Hash table */\n");
	}

#	push(@implContent, "static const char $nameStringTable\[\] =\n\{\n");
#
#	my $s = "\0";
#	push(@implContent, "\t\"\\0\"\n");
#
#	for my $k (sort { length($b) <=> length($a) || $a cmp $b } @$keys) {
#		if ($s =~ /^(.*)\Q$k\E\0/) {
#			$soffset{$k} = length($1);
#		} else {
#			$soffset{$k} = length($s);
#			push(@implContent, "\t\"$k\\0\"\n");
#
#			$s .= $k;
#			$s .= "\0";
#		}
#	}
#
#	push(@implContent, "};\n");

	# Dump the hash table...
	push(@implContent, "\nstatic const struct KJS::HashEntry $nameEntries\[\] =\n\{\n");

	$i = 0;
	foreach $entry (@table) {
		if(defined($entry)) {
			my $key = @$keys[$entry];

#			push(@implContent, "\t\{ " . $soffset{$key});
			push(@implContent, "\t\{ \"" . $key . "\"");
			push(@implContent, ", " . @$values[$entry]);
			push(@implContent, ", " . @$specials[$entry]);
			push(@implContent, ", " . @$parameters[$entry]);
			push(@implContent, ", ");

			if(defined($links[$i])) {
            	push(@implContent, "&${nameEntries}[$links[$i]]" . " \}");
#				push(@implContent, $links[$i] . " \}");
			} else {
				push(@implContent, "0 \}");
#				push(@implContent, "-1 \}");
			}
		} else {
			push(@implContent, "\t\{ 0, 0, 0, 0, 0 \}");
		}

		push(@implContent, ",") unless($i eq $size - 1);
		push(@implContent, "\n");

		$i++;
	}

	push(@implContent, "};\n\n");
	push(@implContent, "const struct KJS::HashTable $name =\n");
	push(@implContent, "{\n\t2, $size, $nameEntries, $savedSize, $nameStringTable\n};\n\n");
}

# Internal helper
sub GenerateHashValue
{
	my $object = shift;

	my $key = shift;
	my @chars = split(/ */, $key);

	my $val = 0;
	foreach(@chars) {
		$val += ord($_);
	}

	return $val;
}

# Internal helper
sub TypeToEcma
{
	my $object = shift;

	my $dataName = shift;
	my %dataType = %{$ref = shift};
	my $inPutMode = shift;

	my $type = $dataType{'type'};
	my $module = $dataType{'namespace'};

	# Quick'n'dirty replace table.
	if($type eq "boolean") {
		$type = "bool";
	} elsif($type eq "string") {
		$type = "QString";
	} elsif($type eq "char") {
		$type = "QChar";
	}

	my $includeFile = 0;

	my $returnValue;
	if($inPutMode eq 0) {
		if($type eq "DOMTimeStamp") { # Known typedef.
			$returnValue = "KJS::Number((long unsigned int) ";
		} elsif($type eq "DOMString") {
			$returnValue = "getDOMString(";
		} elsif($codeGenerator->IsPrimitiveType($type)) {
			if($type eq "bool") {
				$returnValue = "KJS::Boolean(";
			} else {
				$returnValue = "KJS::Number(";
			}
		} else { # TODO: - use getDOMNode/getDOMEvent etc...
			$returnValue = "safe_cache\<${type}Impl, ${type}Wrapper\>(exec, ";
			$includeFile = 1;
		}
	
		$returnValue = "return ${returnValue}m_impl->$dataName());"
	} else {
		if($type eq "DOMString") {
			$returnValue ="toDOMString(exec, value)";
		} elsif($codeGenerator->IsPrimitiveType($type)) {
			if($type eq "bool") {
				$returnValue = "value->toBoolean(exec)";
			} else { # TODO: - toNumber always correct?
				$returnValue = "value->toUInt32(exec)";
			}
		} else {
			$returnValue = "ecma_cast\<${type}Impl\>(exec, value, &to${type})";
			$includeFile = 1;
		}

		$returnValue = "m_impl->$dataName($returnValue);\n\t\t\tbreak;"
	}

	if($includeFile eq 1) {
		if(($module ne "") and ($module ne $useModuleNS)) {
			push(@neededIncludes, "$module/${type}Wrapper");
		} else {
			push(@neededIncludes, "${type}Wrapper");
		}

		if($type eq "NamedNodeMap") { # Exception for 'NamedNodeMap' & Node.cpp.
			push(@neededIncludes, "NamedAttrMapImpl");
		}
	}

	return $returnValue;
}

# Internal helper
sub WriteData
{
	if(defined($IMPL)) {
		# Write content to file.
		print $IMPL @implContent;
		close($IMPL);

		@implContent = "";
	}

	if(defined($HEADER)) {
		# Write content to file.
		print $HEADER @headerContent;
		close($HEADER);

		@headerContent = "";
	}
}

1;
