#
# KDOM IDL parser
#
# Copyright (c) 2005 Nikolas Zimmermann <wildfox@kde.org>
#
package IDLCodeGeneratorCpp;

use DocParser;

my $useModule = "";
my $useModuleNS = "";
my $useOutputDir = "";
my $useDocumentation = "";

my $codeGenerator;

my $IMPL;
my $HEADER;

my @implContent; # .cpp file content
my @headerContent; # .h file content
my @collectedTypes; # Used to build up class forwards
my %dataTypeModuleTable; # Used to map between a 'collected type' & it's module.

# Default .h template
my $headerTemplate = << "EOF";
/*
    This file is part of the KDE project.
    This file has been generated by kdomidl.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/
EOF

# Default constructor
sub new
{
	my $object = shift;
	my $reference = { };

	$codeGenerator = shift;
	$useOutputDir = shift;
	$useDocumentation = shift;

	bless($reference, $object);
	return $reference;
}

sub finish
{
	my $object = shift;

	# Commit changes!
	$object->WriteData();
}

# Params: 'idlDocument' struct
sub GenerateModule
{
	my $object = shift;
	my $dataNode = shift;

	# Create module <-> namespace map...
	$codeGenerator->CreateModuleNamespaceHash();

	$useModule = $dataNode->module;

	my %hash = %{$codeGenerator->ModuleNamespaceHash()};
	$useModuleNS = $hash{$useModule};
}

# Params: 'domClass' struct
sub GenerateInterface
{
	my $object = shift;
	my $dataNode = shift;

	$object->WriteData();

	# Only process parent IDLs if we _really_ need it.
	my @parents = @{$dataNode->parents};
	my $parentsMax = @{$dataNode->parents};

	my $topBaseClass = "";

	# Exception: For the DOM 'Node' is our topmost baseclass, not EventTarget.
	if(($parentsMax > 0) and ($parents[0] ne "events::EventTarget")) { # Determine topmost baseclass, if needed
		my %firstParentType = $codeGenerator->ExtractNamespace($parents[0], 1, $useModuleNS);

		$topBaseClass = $codeGenerator->FindTopBaseClass($firstParentType{'type'});
		my %baseClassType = $codeGenerator->ExtractNamespace($topBaseClass, 1, $useModuleNS);

		if($baseClassType{'type'} ne "") {
			if(($baseClassType{'namespace'} ne "") and ($baseClassType{'namespace'} ne $useModuleNS)) {
				$topBaseClass = $baseClassType{'namespace'} . "::" . $baseClassType{'type'};
			} else {
				$topBaseClass = $baseClassType{'type'};
			}

			print "  |  |----> Determined \"$topBaseClass\" as topmost baseclass!\n  |  |\n";
		}
	}

	# Start actual generation...
	print "  |  |>  Generating header...\n";
	$object->GenerateHeader($dataNode, $topBaseClass);

	print "  |  |>  Generating implementation...\n";
	$object->GenerateImplementation($dataNode, $topBaseClass);

	print " |-\n |\n";
  
	my %type = $codeGenerator->ExtractNamespace($dataNode->name, 1, $useModuleNS);

	# Open files for writing...
	my $implFileName = $useOutputDir . "/$useModule/" . $type{'type'} . ".cpp";
	my $headerFileName = $useOutputDir . "/$useModule/" . $type{'type'} . ".h";

	open($IMPL, ">$implFileName") || die "Coudln't open file $implFileName";
	open($HEADER, ">$headerFileName") || die "Coudln't open file $headerFileName";
}

sub GenerateHeader
{
	my $object = shift;

	my $dataNode = shift;
	my $topBaseClass = shift;

	my $parentsMax = @{$dataNode->parents};
	my %extractedType = $codeGenerator->ExtractNamespace($dataNode->name, 1, $useModuleNS);

	if(!defined($HEADER)) {
		# - Add default header template
		@headerContent = split("\r", $headerTemplate);

		# - Add header protection
		my $printNS = $useModuleNS; $printNS =~ s/\:\:/\_/g;
		push(@headerContent, "\n#ifndef $printNS\_" . $extractedType{'type'} . "_H\n");
		push(@headerContent, "#define $printNS\_" . $extractedType{'type'} . "_H\n");

		# - Add default includes & parent header includes
		push(@headerContent, "\n#include <kdom/kdom.h>\n");
		push(@headerContent, "\n") if($parentsMax > 0);

		foreach(@{$dataNode->parents}) {
			my $includeFile = $codeGenerator->GenerateInclude($_);
			push(@headerContent, "#include \"$includeFile.h\"\n");
		}

		# - Add namespace selector(s)
		# (Add '#FIXUP_NAMESPACE#' marks, which will be replaced later...)
		my @namespaces = @{$codeGenerator->SplitNamespaces($useModuleNS)};

		push(@headerContent, "\n#FIXUP_OTHER#");

		my $collectedNS = "";
		foreach(@namespaces) {
			$collectedNS .= $_ . "::";

			my $showNS = substr($collectedNS, 0, length($collectedNS) - 2);
			push(@headerContent, "namespace $_\n{\n#FIXUP_$showNS#\n");
		}
	}

	# - Add OurClassImpl forward
	push(@headerContent, "\tclass " . $extractedType{'type'} . "Impl;\n\n");

	# - Construct documentation extractor
	my $docExtracter = DocParser->new($useDocumentation, $dataNode);
	push(@headerContent, "\t/**\n\t *\n " . $dataNode->documentation . "\t */\n\n\t");

	# - Add class definition (with correct inheritance order)
	my $parentString = "class " . $extractedType{'type'};

	my $h = 0;
	if($parentsMax > 0) {
		$parentString .= " : ";
	}

	foreach(@{$dataNode->parents}) {
		my %ret = $codeGenerator->ExtractNamespace($_, 1, $useModuleNS);

		if(($ret{'namespace'} ne "") and ($ret{'namespace'} ne $useModuleNS)) {
			$parentString .= "public " . $ret{'namespace'} . "::" . $ret{'type'};
		} else {
			$parentString .= "public " . $ret{'type'};
		}

		$parentString .= ",\n\t\t\t\t" if($h++ < $parentsMax - 1);
	}

	$parentString .= "\n\t{\n\tpublic:\n";
	push(@headerContent, $parentString);

	# - Add default ctor / impl ctor / copy ctor & destructor
	push(@headerContent, "\t\t" . $extractedType{'type'} . "();\n");
	push(@headerContent, "\t\texplicit " . $extractedType{'type'} . "(" . $extractedType{'type'} . "Impl *i);\n");
	push(@headerContent, "\t\t" . $extractedType{'type'} . "(const " . $extractedType{'type'} . " &other);\n");

	if(($parentsMax > 0) and ($topBaseClass ne "")) {
		# Eventually add ctor taking a 'const MyTopMostParent &' object
		push(@headerContent, "\t\t" . $extractedType{'type'} . "(const $topBaseClass &other);\n");
	}

	push(@headerContent, "\t\tvirtual ~" . $extractedType{'type'} . "();\n\n");

	# - Add assignment operator
	push(@headerContent, "\t\t" . $extractedType{'type'} . " &operator=(const " . $extractedType{'type'} . " &other);\n");

	if(($parentsMax > 0) and ($topBaseClass ne "")) {
		# Eventually add assignment operator taking a 'const MyTopMostParent &' object
		push(@headerContent, "\t\t" . $extractedType{'type'} . " &operator=(const $topBaseClass &other);\n");
	}

	# - Add impl assignment operator, if needed
	if($dataNode->noDPtrFlag) {
		push(@headerContent, "\t\t" . $extractedType{'type'} . " &operator=(" . $extractedType{'type'} . "Impl *other);\n");
	}

	# - Add special operators if there are no parents
	if(($parentsMax eq 0) and (!$dataNode->noDPtrFlag)) {
		push(@headerContent, "\t\tbool operator==(const " . $extractedType{'type'} . " &other) const;\n");
		push(@headerContent, "\t\tbool operator!=(const " . $extractedType{'type'} . " &other) const;\n");
	}

	# - Add all constants
	my $i = 0;
	my $constantMax = @{$dataNode->constants};

	# Not needed for cpp dom wrappers, since we have include files for this (kdom.h, ksvg.h etc.)
	#foreach(@{$dataNode->constants}) {
	#	my $constant = $_;
	#
	#	my $constantString = "\n\t\tstatic const " . $object->MapDataType($constant->type) .
	#						  " " . $constant->name . " = " . $constant->value . ";";
	#
	#	$constantString .= "\n" if($i++ eq $constantMax - 1);
	#	push(@headerContent, $constantString);
	#}

	# - Add all attributes
	foreach(@{$dataNode->attributes}) {
		my $attribute = $_;
		my $type = $attribute->signature->type;

		# print documentation lines
		my $attributeString = "\n\t\t/**\n";
		foreach (@{$attribute->documentation}) {
			$attributeString .= "\t\t * " . trim($_) . "\n";
		}

		# at the end come exception lines
		if (defined($attribute->exceptionName)) {
			$attributeString .= "\t\t *\n\t\t * \@exception " . $attribute->exceptionName . "\n";
			foreach (@{$attribute->exceptionDocumentation}) {
				$attributeString .= "\t\t * " . trim($_) . "\n";
			}
		}

		$attributeString .= "\t\t */\n" .
							  "\t\t" . $object->ProcessType($type, $attribute->signature->hasPtrFlag, 1) .
							  $attribute->signature->name . "() const;\n";

		$object->CollectDataType($type, $extractedType{'type'});

		if($attribute->type eq "attribute") { # Read-write accessors!
			my $name = $attribute->signature->name; $name = ucfirst($name);
			$attributeString .= "\t\tvoid set$name(" .
								$object->ProcessType($type, $attribute->signature->hasPtrFlag) .
								$attribute->signature->name . ");\n";
		}
		
		push(@headerContent, $attributeString);
	}

	# - Add all functions
	my $functionMax = @{$dataNode->functions};

	foreach(@{$dataNode->functions}) {
		my $function = $_;
		my $type = $function->signature->type;

		my $functionString = "\n\t\t/*\n\t\t * " . $function->documentation . "\n\t\t */\n" .
							 "\t\t" . $object->ProcessType($type, $function->signature->hasPtrFlag, 1) .
							 $function->signature->name . "(";

		$object->CollectDataType($type, $extractedType{'type'});

		my $k = 0;
		my $parameterMax = @{$function->parameters};
		foreach(@{$function->parameters}) {
			my $parameter = $_;
			$type = $parameter->type;

			$functionString .= $object->ProcessType($type, $parameter->hasPtrFlag) . $parameter->name;
			$functionString .= ", " if($k++ < $parameterMax - 1);

			$object->CollectDataType($type, $extractedType{'type'});
		}

		$functionString .= ");\n";
		push(@headerContent, $functionString);
	}

	# - Add internal section
	push(@headerContent, "\n\t\t// Internal\n");
	push(@headerContent, "\t\tstatic " . $extractedType{'type'} . " null;\n");
	push(@headerContent, "\t\ttypedef " . $extractedType{'type'} . "Impl Private;\n");

	# - Add d-ptr accessor handle()
	push(@headerContent, "\n\t\t" . $extractedType{'type'} . "Impl *handle() const;\n");

	# - Add d-ptr if there are no parents
	if($parentsMax eq 0) {
		push(@headerContent, "\n\tprotected:\n\t\t" . $extractedType{'type'} . "Impl *d;\n");
	}

	# Prepare class forwards...
	my %fixupStrings;
	my $first = 1;

	@collectedTypes = sort { length $a <=> length $b } @collectedTypes;
	foreach(@collectedTypes) {
		my %ret = $codeGenerator->ExtractNamespace($_, 0, $useModuleNS);

		my $namespace = $ret{'namespace'};
		$namespace = $useModuleNS if($namespace eq "");

		my $forward = "\tclass " . $ret{'type'} . ";";
		$forward = "\n$forward" if($first ne 1);

		if(exists($fixupStrings{$namespace})) {
			$fixupStrings{$namespace} .= $forward;
		} else {
			$fixupStrings{$namespace} = $forward;
		}

		if($first eq 1) {
			$first = 0;
		}
	}

	# ... and apply fixups!
	my $tempData = join("@", @headerContent);
	my %otherData;

	while(my($namespace, $forwards) = each %fixupStrings) {
		my $fixupId = "#FIXUP_$namespace#";

		if($tempData =~ /$fixupId/) {
			$tempData =~ s/$fixupId/$forwards\n/;
		} elsif($namespace ne $useModuleNS) {
			$otherData{$namespace} = $forwards . "\n";
		}
	}

	my $otherDataString = "";
	while(my($namespace, $forwards) = each %otherData) {
		$otherDataString .= "\nnamespace $namespace\n{\n$forwards};";
	}

	$otherDataString .= "\n" if($otherDataString ne "");
	$tempData =~ s/#FIXUP_OTHER#/$otherDataString/;

	# If there is a namespace with no forwards just remove the FIXUP mark...
	$tempData =~ s/#FIXUP_[a-zA-Z0-9:]*#//g;

	@headerContent = split("@", $tempData);
	push(@headerContent, "\t};");

	# End header...
	my @namespaces = @{$codeGenerator->SplitNamespaces($useModuleNS)};
	foreach(@namespaces) {
		push(@headerContent, "\n};\n");
	}

	push(@headerContent, "\n#endif\n");
}

sub GenerateImplementation
{
	my $object = shift;

	my $dataNode = shift;
	my $topBaseClass = shift;

	my %extractedType = $codeGenerator->ExtractNamespace($dataNode->name, 1, $useModuleNS);

	if(!defined($IMPL)) {
		# - Add default header template
		@implContent = split("\r", $headerTemplate);

		# - Add absolutely needed includes
		push(@implContent, "\n#include \"" . $extractedType{'type'} . ".h\"\n");

		push(@implContent, "\n#include \"DOMExceptionImpl.h\"");

		my $name = $extractedType{'type'} . "Impl.h";
		if($name =~ /^.*AbsImpl\.h$/) { # Special cases for SVG generation!
			$name =~ s/AbsImpl/Impl/; # include 'SVGPathSegArcImpl.h' not 'SVGPathSegArcAbsImpl.h'
		} elsif($name =~ /^.*RelImpl\.h$/) {
			$name =~ s/RelImpl/Impl/; # include 'SVGPathSegArcImpl.h' not 'SVGPathSegArcRelImpl.h'
		}

		push(@implContent, "\n#include \"$name\"\n");

		# - Add includes for all non-primitive datatypes
		#   (collected & sorted by previous GenerateInterface call)
		foreach(@collectedTypes) {
			if($_ !~ /DOMString$/) { # Already included...
				my $module = $dataTypeModuleTable{$_};
				my %ret = $codeGenerator->ExtractNamespace($_, 0, "");

				my $includeFile = $ret{'type'} . ".h";
				if($module ne "") {
					$includeFile = "$module/$includeFile";
				} 

				push(@implContent, "#include \"$includeFile\"\n");
			}
		}

		my $typesSize = @collectedTypes;
		if(($typesSize > 1) or (($typesSize eq 1) and ($collectedTypes[0] ne "DOMString"))) {
			push(@implContent, "\n");
		}

		# - Add namespace selector(s)
		my @namespaces = @{$codeGenerator->SplitNamespaces($useModuleNS)};
		push(@implContent, "\n");

		my $collectedNS = "";
		foreach(@namespaces) {
			$collectedNS .= $_ . "::";

			my $showNS = substr($collectedNS, 0, length($collectedNS) - 2);
			push(@implContent, "using namespace $showNS;\n");
		}
	}

	# - Add class definition (with correct inheritance order)
	my $assString = "";
	my $assImplString = "";

	my $dtorString = "";

	my $ctorString = "";
	my $ctorImplString = "";

	my $h = 0;
	my $parentsMax = @{$dataNode->parents};
	if($parentsMax > 0) {
		$ctorString .= " : ";
		$ctorImplString .= " : ";
	}

	foreach(@{$dataNode->parents}) {
		$h++;

		my %ret = $codeGenerator->ExtractNamespace($_, 1, $useModuleNS);
		my $type = $ret{'type'};

		if(($ret{'namespace'} ne "") and ($ret{'namespace'} ne $useModuleNS)) {
			$type = $ret{'namespace'} . "::$type";
		}

		$assString .= "\t${type}::operator=(other);";
		$assString .= "\n" if($h < $parentsMax);

		$ctorString .= "$type()";
		$ctorString .= ", " if($h < $parentsMax);

		$ctorImplString .= "$type(i)";
		$ctorImplString .= ", " if($h < $parentsMax);
	}

	if($parentsMax > 0) {
		$assString .= "\n";
		$ctorImplString .= "\n{\n}\n";
	} else {
		$ctorString = " : d(0)";
		$ctorImplString = " : d(i)";

		if($dataNode->noDPtrFlag) {
			$assString = "\tif(d != other.d)\n\t\td = other.d;\n\n";
			$ctorImplString .= "\n{\n}\n";
			$assImplString = "\tif(d != other)\n\t\td = other;\n\n";
		} else { # Common case
			$assString = "\tKDOM_SAFE_SET(d, other.d);\n";
			$ctorImplString .= "\n{\n\tif(d)\n\t\td->ref();\n}\n";
			$dtorString = "\tif(d)\n\t\td->deref();\n";
		}
	}

	my $dptrAccessor = "d";
	if(($parentsMax > 0) and ($topBaseClass ne "")) { # Take d-ptr of topmost base..
		$dptrAccessor = $topBaseClass . "::d";
	}

	my $dptrCheck = "\tif(!d)\n\t";
	if($dptrAccessor ne "d") {
		$dptrCheck = "\tif(!impl)\n\t";
	}

	my $notFoundException = "throw new ";
	if($useModuleNS !~ /^KDOM.*/) {
		$notFoundException .= "KDOM::DOMExceptionImpl(KDOM::NOT_FOUND_ERR);";
	} else {
		$notFoundException .= "DOMExceptionImpl(NOT_FOUND_ERR);";
	}

	# - Add 'impl' define & null object
	push(@implContent, "\n#define impl (static_cast<" . $extractedType{'type'} . "Impl *>($dptrAccessor))\n");
	push(@implContent, "\n" . $extractedType{'type'} . " " . $extractedType{'type'} . "::null;\n\n");

	# - Add default ctor / impl ctor / copy ctor & destructor
	push(@implContent, $extractedType{'type'} . "::" . $extractedType{'type'} . "()$ctorString\n{\n}\n\n");

	push(@implContent, $extractedType{'type'} . "::" . $extractedType{'type'} . "(" .
					   $extractedType{'type'} . "Impl *i)$ctorImplString\n");

	push(@implContent, $extractedType{'type'} . "::" . $extractedType{'type'} . "(const " .
					   $extractedType{'type'} . " &other)$ctorString\n{\n\t(*this) = other;\n}\n\n");

	if(($parentsMax > 0) and ($topBaseClass ne "")) {
		# Eventually add ctor taking a 'const MyTopMostParent &' object
		push(@implContent, $extractedType{'type'} . "::" . $extractedType{'type'} . "(const " .
						   $topBaseClass . " &other)$ctorString\n{\n\t(*this) = other;\n}\n\n");
	}

	push(@implContent, $extractedType{'type'} . "::~" . $extractedType{'type'} . "()\n{\n$dtorString}\n\n");

	# - Add assignment operator
	push(@implContent, $extractedType{'type'} . " &" . $extractedType{'type'} . "::operator=(const " .
					   $extractedType{'type'} . " &other)\n{\n$assString\treturn (\*this);\n}\n");

	if(($parentsMax > 0) and ($topBaseClass ne "")) {
		my @parents = @{$dataNode->parents};

		my %ret = $codeGenerator->ExtractNamespace($parents[0], 1, $useModuleNS);
		my $type = $ret{'type'};

		if(($ret{'namespace'} ne "") and ($ret{'namespace'} ne $useModuleNS)) {
			$type = $ret{'namespace'} . "::$type";
		}

		my $assTwoString = "\t\t\t" . $type . "::operator=(other);\n";

		# Eventually add assigment operator taking a 'const MyTopMostParent &' object
		push(@implContent, "\n" . $extractedType{'type'} . " &" . $extractedType{'type'} . "::operator=(const " .
						   $topBaseClass . " &other)\n{\n\t" . $topBaseClass . "Impl *ohandle = static_cast<" .
						   $topBaseClass . "Impl *>(other.handle());\n\n\tif(impl != ohandle)\n\t{\n\t\tif(!" .
						   "ohandle || 0 /* TODO */)\n\t\t{\n\t\t\tif(impl)\n\t\t\t\timpl->deref();\n\n\t\t\t" .
						   "$dptrAccessor = 0;\n\t\t}\n\t\telse\n$assTwoString\t}\n\n\treturn (\*this);\n}\n");
	}

	# - Add impl assignment operator, if needed
	if($dataNode->noDPtrFlag) {
		push(@implContent, "\n" . $extractedType{'type'} . " &" . $extractedType{'type'} . "::operator=(" .
						   $extractedType{'type'} . "Impl *other)\n{\n$assImplString\treturn (\*this);\n}\n");
	}

	# - Add special operators if there are no parents
	if(($parentsMax eq 0) and (!$dataNode->noDPtrFlag)) {
		push(@implContent, "\nbool " . $extractedType{'type'} . "::operator==(const " .
						   $extractedType{'type'} . " &other) const\n{\n\treturn d == other.d;\n}\n");

		push(@implContent, "\nbool " . $extractedType{'type'} . "::operator!=(const " .
						   $extractedType{'type'} . " &other) const\n{\n\treturn !operator==(other);\n}\n");
	}

	# - Add all attributes
	foreach(@{$dataNode->attributes}) {
		my $attribute = $_;

		my $attributeString = "\n" . $object->ProcessType($attribute->signature->type,
														  $attribute->signature->hasPtrFlag, 1) .
							  $extractedType{'type'} . "::" . $attribute->signature->name . "() const\n{\n";

		my $retName = $object->ReturnStringForType($attribute->signature->type, "impl->" .
					  $attribute->signature->name . "()");

		$attributeString .= "$dptrCheck\t$notFoundException\n\n\treturn $retName\n}\n";

		if($attribute->type eq "attribute") { # Read-write accessors!
			my $name = $attribute->signature->name; $name = ucfirst($name);

			my $type = $object->ProcessType($attribute->signature->type,
											$attribute->signature->hasPtrFlag);

			$attributeString .= "\nvoid " . $extractedType{'type'} . "::set$name($type" .
								$attribute->signature->name . ")\n{\n";

			my $nameString = $attribute->signature->name;
			$nameString .= ".handle()" if($type =~ /const/);

			$attributeString .= "$dptrCheck\t$notFoundException\n\n" .
								"\timpl->set$name($nameString);\n}\n";
		}

		push(@implContent, $attributeString);
	}

	# - Add all functions
	my $j = 0;
	my $functionMax = @{$dataNode->functions};

	foreach(@{$dataNode->functions}) {
		my $function = $_;

		my $functionString = "\n" . $object->ProcessType($function->signature->type,
														 $function->signature->hasPtrFlag, 1) .
							 $extractedType{'type'} . "::" . $function->signature->name . "(";

		my $k = 0;
		my $valueString = "";
		my $parameterMax = @{$function->parameters};
		foreach(@{$function->parameters}) {
			$k++;
		
			my $parameter = $_;
			my $type = $object->ProcessType($parameter->type, $parameter->hasPtrFlag) . $parameter->name;

			$valueString .= $parameter->name;
			$valueString .= ".handle()" if($type =~ /const/);
			$valueString .= ", " if($k < $parameterMax);

			$functionString .= $type;
			$functionString .= ", " if($k < $parameterMax);
		}

		my $name = $object->ReturnStringForType($function->signature->type, "impl->" .
												$function->signature->name . "($valueString)");

		$functionString .= ")\n{\n$dptrCheck\t$notFoundException\n\n\treturn $name\n}";

		$functionString .= "\n" if($j++ < $functionMax - 1);
		push(@implContent, $functionString);
	}

	if($functionMax > 0) {
		push(@implContent, "\n");
	}

	# - Add d-ptr accessor handle()
	push(@implContent, "\n" . $extractedType{'type'} . "Impl *" . $extractedType{'type'} .
					   "::handle() const\n{\n\treturn impl;\n}");

	# End implementation...
	push(@implContent, "\n");
}

# Internal helper
sub MapDataType
{
	my $object = shift;
	my $type = shift;

	if($type eq "boolean") {
		$type = "bool";
	} elsif($type eq "string") {
		$type = "QString";
	} elsif($type eq "char") {
		$type = "QChar";
	}

	return $type;
}

# Internal helper
sub ProcessType
{
	my $object = shift;

	my $type = shift;
	my $ptrFlag = shift;
	my $retFlag = shift;

	my %ret = $codeGenerator->ExtractNamespace($type, 1, $useModuleNS);

	if(($ret{'namespace'} ne "") and ($useModuleNS ne $ret{'namespace'})) {
		$type = $ret{'namespace'} . "::" . $ret{'type'};
	} else {
		$type = $ret{'type'};
	}

	$type = $object->MapDataType($type, $ptrFlag);

	my $data = "";

	if($codeGenerator->IsPrimitiveType($type)) {
		if($ptrFlag) {
			$data = "$type *";
		} else {
			$data = "$type ";
		}
	} else { # Constify if not a primitive
		if($ptrFlag) {
			$data = "$type *";
		} elsif(!defined($retFlag)) {
			$data = "const $type &";
		} else {
			$data = "$type ";
		}
	}

	return $data;
}

# Internal helper
sub ReturnStringForType
{
	my $object = shift;

	my $type = shift;
	my $data = shift;

	my %ret = $codeGenerator->ExtractNamespace($type, 1, $useModuleNS);

	if(($ret{'namespace'} ne "") and ($useModuleNS ne $ret{'namespace'})) {
		$type = $ret{'namespace'} . "::" . $ret{'type'};
	} else {
		$type = $ret{'type'};
	}

	$type = $object->MapDataType($type);

	if($codeGenerator->IsPrimitiveType($type)) {
		return $data . ";";
	}

	return $type . "($data);";
}

# Internal helper
sub CollectDataType
{
	my $object = shift;

	my $typeString = shift;
	my $selfType = shift;

	my %retUnprocessed = $codeGenerator->ExtractNamespace($typeString, 0, $useModuleNS);
	my $module = $retUnprocessed{'namespace'};

	my %ret = $codeGenerator->ExtractNamespace($typeString, 1, $useModuleNS);
	my $type = $ret{'type'};
	my $namespace = $ret{'namespace'};

	# Ignore ourselves...
	if($type eq $selfType) {
		return;
	}

	# Ignore known typedefs...
	if($type eq "DOMTimeStamp") {
		return;
	}

	# Ignore primitives for class forwards...
	if($codeGenerator->IsPrimitiveType($object->MapDataType($type))) {
		return;
	}

	my @array = grep { /^${type}$/ } @collectedTypes;
	my $arraySize = @array;
	if($arraySize eq 0) {
		# Check if it was already added with a 'namespace prefix'?
		my @array = grep { /^.*::${type}$/ } @collectedTypes;
		my $arraySizeTwo = @array;
		if($arraySizeTwo ne 0) {
			$arraySize = 1;
		}
	}

	if($arraySize eq 0) {
		# Exception for 'NamedNodeMap' & Node.cpp, include NamedAttrMapImpl.h
		if(($type eq "NamedNodeMap") and ($selfType eq "Node")) {
			my $identifier = $object->MapDataType("NamedAttrMapImpl");

			push(@collectedTypes, $identifier);
			$dataTypeModuleTable{$identifier} = "";
		}

		my $identifier = $object->MapDataType($type);
		$identifier = $namespace . "::$identifier" if($namespace ne "");
		
		push(@collectedTypes, $identifier);
		$dataTypeModuleTable{$identifier} = $module;
	}
}

# Internal helper
sub WriteData
{
	if(defined($IMPL)) {
		# Write content to file.
		print $IMPL @implContent;
		close($IMPL);
		undef($IMPL);

		@implContent = "";
	}

	if(defined($HEADER)) {
		# Write content to file.
		print $HEADER @headerContent;
		close($HEADER);
		undef($HEADER);

		@headerContent = "";
	}
}

# Internal helper.
sub trim
{
	my $string = shift;
	for($string) {
		s/^\s+//;
		s/\s+$//;
	}

	return $string;
}

1;
